<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Computing Dynamics</title>
  
  <subtitle>小王同学的工作站</subtitle>
  <link href="http://chudod.github.io/atom.xml" rel="self"/>
  
  <link href="http://chudod.github.io/"/>
  <updated>2022-05-31T04:42:09.412Z</updated>
  <id>http://chudod.github.io/</id>
  
  <author>
    <name>虎王</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Русская Граммаатика(俄语语法)</title>
    <link href="http://chudod.github.io/2022/05/24/Russian_Grammar/"/>
    <id>http://chudod.github.io/2022/05/24/Russian_Grammar/</id>
    <published>2022-05-23T16:00:00.000Z</published>
    <updated>2022-05-31T04:42:09.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="名词变格"><a href="#名词变格" class="headerlink" title="名词变格"></a>名词变格</h1><h2 id="单数第四格"><a href="#单数第四格" class="headerlink" title="单数第四格"></a>单数第四格</h2><h3 id="变化形式"><a href="#变化形式" class="headerlink" title="变化形式"></a>变化形式</h3><p><head><br>    <meta charset="utf-8"></p><p><h4 align="center">名词单数第四格</h4></p><table align="center"><tr>    <td style="border: 1px solid black" colspan="2" align="center"></td>    <td style="border: 1px solid black" align="center">第一格</td>    <td style="border: 1px solid black" align="center">第二格</td>    <td style="border: 1px solid black" align="center">第四格</td>    <td style="border: 1px solid black" align="center">记忆</td></tr><tr>    <td style="border: 1px solid black" rowspan="2" align="center">阳性</td>    <td style="border: 1px solid black" align="center">非动物</td>    <td style="border: 1px solid black" align="center">фильм<br>музей<br>портфель<br></td>    <td style="border: 1px solid black" align="center">фильма<br>музея<br>портфеля<br></td>    <td style="border: 1px solid black" align="center">фильм<br>музей<br>портфель<br></td>    <td style="border: 1px solid black" align="center">第四格与第一格相同    </td></tr><tr>    <td style="border: 1px solid black" align="center">动物</td>    <td style="border: 1px solid black" align="center">студент<br>герой<br>учитель<br></td>    <td style="border: 1px solid black" align="center">студента<br>героя<br>учителя<br></td>    <td style="border: 1px solid black" align="center">студента<br>героя<br>учителя<br></td>    <td style="border: 1px solid black" align="center">第四格与第二格相同    </td></tr><tr>    <td style="border: 1px solid black"  align="center">阴性</td>    <td style="border: 1px solid black" align="center">所有名词（动物和非动物）</td>    <td style="border: 1px solid black" align="center">школа<br>сестра<br>кухния<br>    тётя<br>тетрадь<br>дочь<br></td>    <td style="border: 1px solid black" align="center">школы<br>сестры<br>кухни<br>    тёти<br>тетради<br>дочи<br></td>    <td style="border: 1px solid black" align="center">школу<br>сестру<br>кухню<br>    тётю<br>тетрадь<br>дочь<br></td>    <td style="border: 1px solid black" align="center">第一、二、四格各异<br>第四格变化：-а变-у，-я变ю, -ь不变    </td></tr></table><p>注意：</p><ul><li>以-а和-я结尾的阳性词按照阴性词第四格来变化，例如：папа-паппу、дёду-дёду</li><li>第四格变化记忆方法：阴性词-а变-у，-я变ю, -ь不变，阳性词非动物词不变，动物词同第二格。</li></ul><p><head><br>    <meta charset="utf-8"></p><p><h4 align="center">物主代词和指示代词单数第四格</h4></p><table align="center"><tr>    <td style="border: 1px solid black"  align="center">词性</td>    <td style="border: 1px solid black" align="center">第一格</td>    <td style="border: 1px solid black" align="center">第四格</td>    <td style="border: 1px solid black" align="center">记忆</td></tr><tr>    <td style="border: 1px solid black"  rowspan ="2" align="left">阳性</td>    <td style="border: 1px solid black" align="left">мой<br>наш (журнал)<br>этот<br></td>    <td style="border: 1px solid black" align="left">мой<br>наш (журнал)<br>этот<br></td>    <td style="border: 1px solid black" align="left">与非动物名词连用：第四格与第一格相同    </td></tr><tr>    <td style="border: 1px solid black" align="left">мой<br>наш (брат)<br>этот<br></td>    <td style="border: 1px solid black" align="left">моего<br>нашего (брат)<br>этого<br></td>    <td style="border: 1px solid black" align="left">与非动物名词连用：结尾-его或者-ого    </td></tr><tr>    <td style="border: 1px solid black"  align="left">中性</td>    <td style="border: 1px solid black" align="left">моё<br>наше<br>это<br></td>    <td style="border: 1px solid black" align="left">моё<br>наше<br>это<br></td>    <td style="border: 1px solid black" align="left">第四格与第一格相同    </td></tr><tr>    <td style="border: 1px solid black"  align="left">阴性</td>    <td style="border: 1px solid black" align="left">мая<br>наша<br>эта<br></td>    <td style="border: 1px solid black" align="left">мою<br>нашу<br>эту<br></td>    <td style="border: 1px solid black" align="left">-а变-у，-я变ю    </td></tr></table><p><head><br>    <meta charset="utf-8"></p><p><h4 align="center">весь单数第四格</h4></p><table align="center"><tr>    <td style="border: 1px solid black"  align="center">词性</td>    <td style="border: 1px solid black" align="center">第一格</td>    <td style="border: 1px solid black" align="center">第四格</td>    <td style="border: 1px solid black" align="center">记忆</td></tr><tr>    <td style="border: 1px solid black"  rowspan ="2" align="left">阳性</td>    <td style="border: 1px solid black" align="left">весь (журнал)</td>    <td style="border: 1px solid black" align="left">весь (журнал)</td>    <td style="border: 1px solid black" align="left">与非动物名词连用：第四格与第一格相同    </td></tr><tr>    <td style="border: 1px solid black" align="left">весь (учитель)</td>    <td style="border: 1px solid black" align="left">всего (учитель)</td>    <td style="border: 1px solid black" align="left">与非动物名词连用：结尾-его或者-ого    </td></tr><tr>    <td style="border: 1px solid black"  align="left">中性</td>    <td style="border: 1px solid black" align="left">всё</td>    <td style="border: 1px solid black" align="left">всё</td>    <td style="border: 1px solid black" align="left">第四格与第一格相同    </td></tr><tr>    <td style="border: 1px solid black"  align="left">阴性</td>    <td style="border: 1px solid black" align="left">вся</td>    <td style="border: 1px solid black" align="left">всю</td>    <td style="border: 1px solid black" align="left">-я变ю    </td></tr></table><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="1、作“宾语”"><a href="#1、作“宾语”" class="headerlink" title="1、作“宾语”"></a>1、作“宾语”</h4><p><head><br>    <meta charset="utf-8"></p><p><h4 align="center"></h4></p><table align="center"><tr>    <td style="border: 2px solid black" align="center">及物动词+第四格：</td>    <td style="border: 2px solid black" align="center">слушает музыку(听音乐)</td></tr><tr>    <td style="border: 2px solid black" align="center">不及物动词+前置词+第四格：</td>    <td style="border: 2px solid black" align="center">играть в футбол(踢足球)</td></tr></table><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><p>1、Я хорошо знаю <strong>учителя Чжана</strong>.     我很认识张老师。<br>2、Анан очен любит <strong>сына Виктора</strong> и <strong>дочь Нину</strong>.    安娜非常喜欢儿子维克多和女儿妮娜。  </p><h4 id="2、В或На加上第四格：去哪、去做…事"><a href="#2、В或На加上第四格：去哪、去做…事" class="headerlink" title="2、В或На加上第四格：去哪、去做…事"></a>2、В或На加上第四格：去哪、去做…事</h4><p><head><br>    <meta charset="utf-8"></p><p><h4 align="center"></h4></p><table align="center"><tr>    <td style="border: 2px solid black" align="center">В + 第四格：</td>    <td style="border: 2px solid black" align="center">去哪里(куда)</td></tr><tr>    <td style="border: 2px solid black" align="center">На + 第四格：</td>    <td style="border: 2px solid black" align="center">去做什么</td></tr></table><h5 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h5><p>1、Куда идёт учитель? Он едёт <strong>в</strong> <strong>школу</strong>.<br>老师去哪里？     -他去学校<br>2、Куда идут студенты? Они идут <strong>в</strong> <strong>библотеку</strong>.<br>大学生们去哪里？     -他们去图书馆。<br>注意：завод(工厂)和почта(邮局)的前置词用на<br>3、Мы идём <strong>на</strong> <strong>завод</strong>. 我们乘车去工厂。<br>4、<strong>Эта</strong> студентка идёт <strong>на</strong> <strong>почту</strong>. 这位女大学生正前往邮局。  </p><h4 id="3、第四格-动词：行为持续时间"><a href="#3、第四格-动词：行为持续时间" class="headerlink" title="3、第四格+动词：行为持续时间"></a>3、第四格+动词：行为持续时间</h4><h5 id="举例：-2"><a href="#举例：-2" class="headerlink" title="举例："></a>举例：</h5><p>1、<strong>Год</strong> мы жили в деревне. 我们在农村住了一年。<br>2、Моя бабушка <strong>каждый</strong> <strong>день</strong> вечером смотрит телевизар. 我奶奶每天晚上看电视。<br>3、Он говорил по телефону <strong>десять</strong> <strong>минут</strong>. 他在电话里讲了十分钟。<br>4、Папа и Иван <strong>весь</strong> <strong>вечер</strong> играли в шахматы. 爸爸和伊万整整一个晚上在下象棋。<br>5、<strong>Всю субботу</strong> Иваи читал <strong>эту книгу</strong>. 星期六一整天伊万一直在读这本书。  </p><h4 id="代词第四格"><a href="#代词第四格" class="headerlink" title="代词第四格"></a>代词第四格</h4><h5 id="举例：-3"><a href="#举例：-3" class="headerlink" title="举例："></a>举例：</h5><p>1、Ты читал <strong>зтот</strong> <strong>жулнал</strong>? -Нет, <strong>ещё</strong> не читал.<br>你读过这本杂志吗？ -还没有。<br>2、Вы знаете <strong>нашего</strong> учителя? (<strong>нашу</strong> <strong>учительнису</strong>). -Да, я знаю <strong>вашего</strong> учителя, он мой сосед.<br>您认识我们的老师吗？ -是，我认识你们的老师，他是我的邻居。<br>3、Я не видел <strong>твоего</strong> <strong>брата</strong>, а видел <strong>твою</strong> сестру.<br>我没看见你的弟弟，但看见了你的妹妹。</p><h2 id="第三格"><a href="#第三格" class="headerlink" title="第三格"></a>第三格</h2><h3 id="人称代词第三格"><a href="#人称代词第三格" class="headerlink" title="人称代词第三格"></a>人称代词第三格</h3><div class="table-container"><table><thead><tr><th style="text-align:center">第一格</th><th style="text-align:center">я</th><th style="text-align:center">ты</th><th style="text-align:center">он, оно</th><th style="text-align:center">она</th><th style="text-align:center">мы</th><th style="text-align:center">вы</th><th style="text-align:center">они</th></tr></thead><tbody><tr><td style="text-align:center">第二、六格</td><td style="text-align:center">меня</td><td style="text-align:center">тебя</td><td style="text-align:center">его</td><td style="text-align:center">её</td><td style="text-align:center">нас</td><td style="text-align:center">вас</td><td style="text-align:center">их</td></tr><tr><td style="text-align:center">第三格</td><td style="text-align:center">мне</td><td style="text-align:center">тебе</td><td style="text-align:center">ему</td><td style="text-align:center">ёй</td><td style="text-align:center">нам</td><td style="text-align:center">вам</td><td style="text-align:center">им</td></tr></tbody></table></div><h1 id="过去式"><a href="#过去式" class="headerlink" title="过去式"></a>过去式</h1><h2 id="变化形式-1"><a href="#变化形式-1" class="headerlink" title="变化形式"></a>变化形式</h2><p><head><br>    <meta charset="utf-8"></p><p><h4 align="center">动词过去式词尾变化</h4></p><table align="center"><tr>    <td style="border: 1px solid black" colspan="3" align="center">人称代词</td>    <td style="border: 1px solid black" align="center">быть</td>    <td style="border: 1px solid black" align="center">说明</td></tr><tr>    <td style="border: 1px solid black" rowspan="3" align="center">单数</td>    <td style="border: 1px solid black" align="center">阳</td>    <td style="border: 1px solid black" align="center">он(я ты)</td>    <td style="border: 1px solid black" align="center">был</td>    <td style="border: 1px solid black" rowspan="4" align="center">结尾去掉-сь再分别按词性加上-л、ла、-ло、-ли</td></tr><tr>    <td style="border: 1px solid black" align="center">阴</td>    <td style="border: 1px solid black" align="center">она(я ты)</td>    <td style="border: 1px solid black" align="center">была</td></tr><tr>    <td style="border: 1px solid black" align="center">中</td>    <td style="border: 1px solid black" align="center">оно</td>    <td style="border: 1px solid black" align="center">было</td></tr><tr>    <td style="border: 1px solid black" colspan="2" align="center">复数</td>    <td style="border: 1px solid black" align="center">они(мы вы)</td>    <td style="border: 1px solid black" align="center">были</td></tr></table><p><head><br>    <meta charset="utf-8"></p><p><h4 align="center">带-ся动词过去式的结尾变化</h4></p><table align="center"><tr>    <td style="border: 1px solid black" align="center">улыба-加</td>    <td style="border: 1px solid black" align="center">лся（阳）<br>лась（阴）<br>лося（中）<br>лися（复）<br></td>    <td style="border: 1px solid black" align="center">辅音结尾加-ся，元音结尾加-сь</td></tr></table><p>记忆方法：улыба<del>ть</del>ся加上-л、ла、-ло、-ли</p><h3 id="举例：-4"><a href="#举例：-4" class="headerlink" title="举例："></a>举例：</h3><p>1、Моя муж вчера <strong>смотрел</strong> этот филимю. 我丈夫昨天看了这个电影。<br>2、Кагда мы <strong>жили</strong> в деревне, мы обычно <strong>проводили</strong> свободное время. 当我们住在农村时，我们经常一起度过空闲时光。<br>3、Сегодня утром Сергей <strong>был</strong> в библиотеке. 今天早上谢尔盖去过图书馆。  </p><h1 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h1><p>用который来做关联词，相当于英语中的which，注意词性变化即可：  </p><p><head><br>    <meta charset="utf-8"></p><p><h4 align="center">который词性变化</h4></p><table align="center"><tr>    <td style="border: 2px solid black" align="center">который</td>    <td style="border: 2px solid black" align="center">который（阳）<br>которая（阴）<br>которое（中）<br>которые（复）<br></td></tr></table><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>1、Я знаю студент, <strong>который</strong> идёт на магазин. 我认识正在去商店的那个男大学生。<br>2、Я знаю студентку, <strong>которая</strong> идёт в библиотеку. 我认识正在去图书馆的那个女大学生。<br>3、Я чидаю письмо, <strong>которое</strong> лежало на столе. 我读曾放在桌子上的信。<br>4、Картины, <strong>которые</strong> висят у вас конмате очен красивые. 挂在您房间里的几幅画非常漂亮。  </p><h1 id="动词的体"><a href="#动词的体" class="headerlink" title="动词的体"></a>动词的体</h1><pre class="mermaid">graph LRA(动词)---->B1(完成体)A(动词)---->B2(未完成体)B1---->C1(过去时)B1---->C2(将来时)B2---->C3(过去时)B2---->C4(现在时)B2---->C5(现在时)</pre><h2 id="完成体和未完成体对比"><a href="#完成体和未完成体对比" class="headerlink" title="完成体和未完成体对比"></a>完成体和未完成体对比</h2><p><head><br>    <meta charset="utf-8"></p><p><h4 align = "center">动词的体(以он为例)</h4></p><table align = "center"><tr>    <td style="border: 1px solid black"  align="center"></td>    <td style="border: 1px solid black" align="center">完成体<br>прочитать</td>    <td style="border: 1px solid black" align="center">未完成体<br>читать</td></tr><tr>    <td style="border: 1px solid black"  align="center">过去时</td>    <td style="border: 1px solid black" align="center">прочитал</td>    <td style="border: 1px solid black" align="center">читал</td></tr><tr>    <td style="border: 1px solid black"  align="center">现在时</td>    <td style="border: 1px solid black" align="center">无</td>    <td style="border: 1px solid black" align="center">читает</td></tr><tr>    <td style="border: 1px solid black"  align="center">将来时</td>    <td style="border: 1px solid black" align="center">прочитает</td>    <td style="border: 1px solid black" align="center">будент читать</td></tr></table><p><strong>注：完成体动词没有现在时，并且变位法和未完成体一样，换言之，只要完成体动词变位了，那么一定是将来时。</strong></p><h2 id="完成体"><a href="#完成体" class="headerlink" title="完成体"></a>完成体</h2><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p>表示已经完成或者将要完成。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><h5 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h5><p>1、Вечер я <strong>паписал</strong> писимо домой. 昨天我给家里写了一封信。<br>2、В деревне <strong>пастройли</strong> школу. 村里建了一所学校。<br>3、Я <strong>прочитает</strong> эту статью. 我要把这篇文章读完。<br>4、Сегодня утром Вадим <strong>купил</strong> газеду &lt;&lt;Правда&gt;&gt; в киоске. 今早瓦季姆在报刊亭买了一份真理报。  </p><h4 id="完成体的将来时"><a href="#完成体的将来时" class="headerlink" title="完成体的将来时"></a>完成体的将来时</h4><p>未完成体动词和完成体动词均有将来时，完成体动词的变位法与未完成体动词变位法完全相同。</p><h5 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h5><p>1、Кагда ты <strong>*прочитаешь</strong> эту кннигу? -Наверно, завтра её <strong>прочитаю</strong>.<br>你什么时候能把这本书读完？ 大概明天能读完。<br>2、Вы <strong>паписали</strong> статью в газету? -Простите, ещё не <strong>паписал</strong>. Видите, сейчас пишу. Напишу её сёйчас.<br>您给报社的文章写完了吗？ 请原谅，还没有。我现在正在写，今天就把他写好。<br>3、Лариса <strong>поедёт</strong> в Аэрофлот в восем часов, и приедёт куда в девять. 拉丽莎8点坐车去航空总局，9点就能到那。  </p><h2 id="未完成体"><a href="#未完成体" class="headerlink" title="未完成体"></a>未完成体</h2><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><h5 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h5><p>1、Они сейчас <strong>строят</strong> школу в деревне. 他们现在在村子里建造学校。<br>2、Они <strong>строили</strong> школу в деремне 他们曾在村子里建造学校。<br>3、Кагда Вадим <strong>покупал</strong> книгу в киоске, он <strong>увидел</strong> Наташу. 当瓦季姆在报刊亭买了一份报纸时，他看见了娜塔莎。  </p><h4 id="动作与时间相关"><a href="#动作与时间相关" class="headerlink" title="动作与时间相关"></a>动作与时间相关</h4><p>未完成时可用来表示经常反复的行为，例如：<br>Каждый день мы читаем по-руский. -我们每天读俄语。<br>通常与долго(需很长时间)、недолго、весь вечер(每晚)、два часа(两小时)连用，也可以表示动作持续的时间。通常与обычно(通常)、часто(经常)、всегда(总是)、инагда(有时)、Каждый день(每天)连用。  </p><h5 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h5><p>1、Я <strong>читал</strong> эту статью два часа. 这篇文章我读了2个小时。<br>2、Они <strong>строят</strong> эту школу шестой месяц. 他们盖这所学校已经有5个月了。<br>3、Каждый дент студенты <strong>читают</strong> газеты. 大学生们每天都阅读报纸。<br>4、Вадим часто <strong>покупал</strong> газеты в киоске у Тани. 瓦季姆过去常在塔尼亚的报刊亭买报纸(用у加第二格表示某人拥有，其中Тани为Таня的第二格形式)。<br>5、<strong>Каждую</strong> <strong>неделю</strong> Атон писал письма домой. 安东过去每个星期都要给家里写信(письмо的复数形式为письма)。  </p><h4 id="动词不定式"><a href="#动词不定式" class="headerlink" title="动词不定式"></a>动词不定式</h4><p>及物动词（完成体和未完成体）可以做独立动词或则助动词：<br>|       | 独立动词 |助动词|<br>|:——-:|:——-:|:——-:|<br>|及物动词|与不带前置词的第四格连用|与<strong>未完成体</strong>不定式连用，表示开始、继续、结束某行为|<br>|不及物动词(-ся结尾)|第一格作主语即可|不能做助动词！|<br><strong>注1：完成体和未完成体都可以做助动词！</strong> начать 完(начинать 未完)、продолжать(继续) кончить 完(кочать 未完)多可以做助动词，与未完成体不定式(动词原形)连用：кончать работать、продолжать читать、кочать писать<br>注2：完成体和未完成体都可以加上-ся变成不及物动词：Урок <strong>начался</strong>. 开始上课了。<br>注3：продолжать的完成体продолжить不能做助动词。</p><h5 id="举例-助动词"><a href="#举例-助动词" class="headerlink" title="举例(助动词)"></a>举例(助动词)</h5><p>1、Преподватель продолжал <strong>читать</strong> новой урок. 教师继续读新的课文。<br>2、Олег начинает <strong>рассказывать</strong>, как стройли Академго-родок в Новосибирнике. 奥列格开始讲述在西伯利亚是如何建设科学城的。<br>3、Кагда Олег кончил <strong>рассказывать</strong>, он начал <strong>показывать</strong> новые фотографии. 奥列格讲完后，他就把新的照片开始给人家看。<br>4、Кагда они кончили <strong>играть</strong> в шахматы, кончилась и интересная передача по телевизору. 当他们下完象棋时，精彩的电视节目也就结束了(кончилась是不及物动词кончится的过去式形式)。</p>]]></content>
    
    
    <summary type="html">基本俄语语法整理</summary>
    
    
    
    <category term="Россия" scheme="http://chudod.github.io/categories/%D0%A0%D0%BE%D1%81%D1%81%D0%B8%D1%8F/"/>
    
    
    <category term="Россия" scheme="http://chudod.github.io/tags/%D0%A0%D0%BE%D1%81%D1%81%D0%B8%D1%8F/"/>
    
  </entry>
  
  <entry>
    <title>文件系统概念和Ext2文件系统</title>
    <link href="http://chudod.github.io/2022/05/18/OS_FileSystem/"/>
    <id>http://chudod.github.io/2022/05/18/OS_FileSystem/</id>
    <published>2022-05-17T16:00:00.000Z</published>
    <updated>2022-05-21T03:38:42.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h1><p>我在本科第一次学习“文件系统”时，觉得这一章的很多概念仿佛如空中楼阁，因为“文件系统”太抽象了，后来才慢慢加深理解，其实文件系统就是磁盘管理，也可以说文件系统是物理设备的高级抽象。硬盘（低速设备）读写单位是扇区，通常为512 Bytes，而文件系统的读写单位是块（若干个扇区组成，为了避免频繁访问磁盘，一次读入多个块）。为了管理这些块，需要各种数据结构。</p><h2 id="inode和文件控制块FCB"><a href="#inode和文件控制块FCB" class="headerlink" title="inode和文件控制块FCB"></a>inode和文件控制块FCB</h2><p>一个文件被拆分成多个块来存储，因此需要一种文件组织方式。以Windows的FAT32为例，FAT是文件分配表(File Allocation Table)，所有的块被用链式结构来组织，在每一块的最后记录下一块的地址，这样文件不需要连续存储，节省了磁盘空间。FAT文件系统为每个文件都分配了一个FAT表，用单独的链式结构来存储、跟踪文件的所有块。FAT文件系统的缺点是文件查找效率地下，为了定位到最后一个数据块，需要遍历前面的所有数据块，且每访问一个块就涉及一次磁盘寻道，使得本就低速的磁盘访问更加频繁，也许微软受不了FAT32文件系统，后来推出了NTFS文件系统(下图来自《操作系统概念》)。</p><p><div style = "align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB200ceca287a455a1754af8fc6e802128?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="40%" height="40%"/>  </p><p>Unix的文件系统比较先进，采用索引结构来组织文件块，文件块依然可以零散地分布在磁盘中，但Unix文件系统为每个文件的所有块都建立了一个索引表，索引表就是块地址数组，数组元素就是块的地址，访问任意一个块只需要从索引表获得块地址就可以了，速度大大提升。包含此索引表的索引结构就是index node，简称inode(i节点)。任何一个文件都有一个inode，inode记录了文件的所有信息，包括一个索引表，记录文件所有块的块地址。索引结构的缺点是索引结构本身要占一定的存储空间，文件越大，块越多，索引表越大，因此Unix采取了一个折中的方法，采用多级索引结构：inode的索引表一共15个索引项，如果文件块小于12块，那么将这12块的块地址直接存储在前12个索引项中，这前面12个索引可以直接获得块地址，如果文件大于12块，就用第13个索引（一级索引指针）指向一个新的块，新的一块存储256个块地址（一个块1024字节，一个块地址4字节，所以可以存储256个块地址），因此一级索引结构可以存储12+256=268个块。如果文件大于268个块，就建立二级索引指针，因此inode索引表的第14个索引是二级索引指针，，第15个是三级索引指针，这样可以管理非常大的文件（文件最多$12+256+256\times{256}+256\times{256}\times{256}块\approx{16.06G}$，如果一个块1024个字节）。</p><p><div style = "align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB5c6be0c67c8d7e412bb46a0fc7dfc4b2?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="50%" height="50%"/>  </p><p>只要用于控制和管理文件相关信息的数据结构都叫文件控制块FCB(File Control Block)，因此inode也是FCB的一种。并且inode的数量等于文件数量，为了方便管理，分区中所有文件的inode都用一个大表格(inode_table)来维护，用单独的几个磁盘块来存储这个表格，再结合inode位图（单独的一块）。表格就是一个数组，数组中的元素就是inode地址，数组的下标就是inode的编号。可以根据inode编号来查询inode地址。Linux中的inode的定义如下（少了3个字段，但是不重要，没贴出来，来自《深入理解Linx内核》）：</p><p><div style = "align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB59ac0acfacd302c44a1c25b94075ea37?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/>  </p><h2 id="目录项与目录"><a href="#目录项与目录" class="headerlink" title="目录项与目录"></a>目录项与目录</h2><p>在Unix的inode中，缺少了一个对用户来说至关重要的属性：文件名。用户给出文件名来访问文件，而文件系统通过inode来定位数据块（文件名对文件系统来说不重要，有了inode即可）。因此目录的作用就是将文件名和inode绑定。用户给出文件名，文件在目录项中找到文件名对应的inode，然后再找到数据块。<br>在Linux中，目录和文件都用inode来表示，因此目录也是一种文件。inode同时指向目录和普通文件，磁盘文件系统中没有一种叫做目录的数据结构，磁盘上有的只是inode，inode指向文件实体的数据块，而不关心数据块具体的内容，因此目录和普通文件本质的区别就是“数据块上记录的内容”不同。例如，一个.txt文本文件的数据块记录的是文本文件的ASCII码，而一个目录文件的数据块，记录的内容是目录下包含的所有目录项，如下所示：</p><p><div style = "align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB3edb3a5062775e84e27a1b3baf7214d4?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/>  </p><p>其中’.’表示当前目录，’..’表示上一级目录，每一个目录项的字段如下所示：</p><p><div style = "align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB8ccdb56ae2d2ddd63d7a13a576d23bb1?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> </p><p>目录项长度通常为4的倍数，不足4的倍数会在文件名末尾补上’\0’。可以看到，目录项包含文件对应的inode索引，因此获得这个索引之后，就可以根据该索引值计算出inode地址，然后就可以得到文件的inode了。这一个inode指向的文件也可能是目录文件，因此数据块中包含目录项，这样就可以根据多级目录来查询了。另外，不管是普通文件还是目录文件（这里将目录称之为“目录文件”），总会位于一个目录下，所有普通文件和目录都位于根目录’/‘下，根目录是所有目录的父目录。<br>我本科学到这里的时候被绕晕了：要想找到数据块，必须找到文件的inode，而要找到文件的inode，又必须要知道目录项（目录项包含inode索引），而要找到目录项又必须先找到数据块（目录项本身又是目录文件数据块里面的内容）……寻找过程似乎是个死循环。这种看似死循环的过程，原因无外乎就是上层目录是无休止的，因此有个固定的目录就可以了，答案就是根目录’/‘！每个分区都有自己的根目录，根目录是所有目录的父目录，在创建文件分区的时候就已经在一个固定死的位置写好了根目录的inode，查找文件时时都首先根据根目录inode获得根目录数据块，然后再查找这个数据块里面的目录项，最后递归查找，找到任意子目录的文件。因此查找/home/hello.txt文件的过程是：</p><ul><li>1、文件系统找到根目录’/‘的inode</li><li>2、由根目录的inode找到根目录的数据块</li><li>3、根目录数据块中有home目录项，并由home目录项找到home这个目录文件的inode</li><li>5、由home目录文件的inode找到home目录的数据块</li><li>6、home目录数据块有hello.txt目录项，并由该目录项找到hollo.txt这个文件的inode</li><li>7、由hello.txt文件的inode找到对应的数据块，数据块存储着字符串的ASCII码值。</li></ul><h2 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h2><p>Ext2文件系统在磁盘上的布局如下图所示：<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB8773c112d52de95d6691bdec4e7ea012?method=download&amp;shareKey=69113f8f61e335d1864757cf6d288929" alt=""><br>Ext2文件系统将若干个块分成一个组，一个分区可能有多个块组。</p><ul><li>在整个磁盘中，最开始一个块是引导块，包含引导操作系统的相关信息，MBR(Master Boot Record和Loader程序就在这个块中)。如果该磁盘不包含操作系统，则该块内容为空。NTFS文件系统称该之为分区引导扇区。</li><li><p>每个块组的第一块是超级块，是在为分区创建文件系统时创建的，超级块包含总的inode数量、块的数量、每块的大小（字节）、每组的块数等等这些重要信息，详细字段如下所示：<br><div style = "align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBb353acd38c3d124728dfb939d9eb1472?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> </p></li><li><p>组描述符紧跟着超级块，记录着数据块位图从几号块开始、inode位图从几号块开始、inode节点从几号块开始等等信息，具体字段如下：<br><div style = "align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB4f0be2bb01668eba716ad737927f1217?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/></p></li><li><p>之后是数据块位图和inode位图，记录那些块被（数据块或者inode）使用过了，1比特表示对应的块被使用过了。</p></li><li>索引节点块存储所有inode。</li><li>后面的所有块均为存储数据的数据块（存储目录文件、普通文件）</li></ul><h2 id="Ext2文件系统实例"><a href="#Ext2文件系统实例" class="headerlink" title="Ext2文件系统实例"></a>Ext2文件系统实例</h2><p>现有一个磁盘had.raw，根目录的内容如下，一共4个文件（包括目录）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">..</span><br><span class="line">lost+found</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure><br>利用hexdump命令查看磁盘内容：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C rootfs/hda.raw | less</span><br></pre></td></tr></table></figure><br>磁盘内容如下，可以根据各个块的字段来查看意义：</p><h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br><span class="line"><span class="comment">//以上为引导块（0号块），接下来为超级块（1号块）</span></span><br><span class="line"><span class="number">00000400</span>  <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">08</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">66</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> cd <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>  |........f.......|</span><br><span class="line">          ^_________^ ^_________^</span><br><span class="line">        s_inodes_count s_blocks_count</span><br><span class="line"><span class="number">00000410</span>  f4 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">                                   ^_________^</span><br><span class="line">                                   s_log_block_size</span><br><span class="line"><span class="number">00000420</span>  <span class="number">00</span> <span class="number">20</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">20</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">43</span> <span class="number">54</span> <span class="number">9</span>e <span class="number">5</span>e  |. ... ......CT.^|</span><br><span class="line">          ^_________^              ^_________^</span><br><span class="line">          s_blocks_per_group       s_inodes_per_group</span><br><span class="line"><span class="number">00000430</span>  c8 <span class="number">56</span> <span class="number">9</span>e <span class="number">5</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">15</span> <span class="number">00</span>  <span class="number">53</span> ef <span class="number">01</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |.V.^....S.......|</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">值</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">s_inodes_count</td><td style="text-align:center">0x0100</td><td style="text-align:center">总共包含0x0100个inode</td></tr><tr><td style="text-align:center">s_blocks_count</td><td style="text-align:center">0x0800</td><td style="text-align:center">总共包含0x0800块</td></tr><tr><td style="text-align:center">s_log_block_size</td><td style="text-align:center">0x0000</td><td style="text-align:center">块大小为$1024\times{2^0}$，即1024B</td></tr><tr><td style="text-align:center">s_blocks_per_group</td><td style="text-align:center">0x2000</td><td style="text-align:center">每组包含0x2000块</td></tr><tr><td style="text-align:center">s_inodes_per_group</td><td style="text-align:center">0x0100</td><td style="text-align:center">每组包含0x0100(256)个inode，占$\frac{256}{8}=32$个块</td></tr></tbody></table></div><p>其中每个inode占128字节，因此一个块包含$\frac{1024}{128}=8$个inode。</p><h3 id="组描述符"><a href="#组描述符" class="headerlink" title="组描述符"></a>组描述符</h3><p>组描述符紧跟着超级块<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为组描述符（2号块）</span></span><br><span class="line"><span class="number">00000800</span>  <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> cd <span class="number">07</span> f4 <span class="number">00</span>  |................|</span><br><span class="line">          ^_________^ ^_________^  ^_________^</span><br><span class="line">     bg_clock_bitmap bg_inode_bitmap bg_inode_table</span><br><span class="line"><span class="number">00000810</span>  <span class="number">02</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line"><span class="number">00000820</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br></pre></td></tr></table></figure></p><div class="table-container"><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">值</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">bg_clock_bitmap</td><td style="text-align:center">0x03</td><td style="text-align:center">数据块位图区从3号块开始</td></tr><tr><td style="text-align:center">bg_inode_bitmap</td><td style="text-align:center">0x04</td><td style="text-align:center">inode位图区从4号块开始</td></tr><tr><td style="text-align:center">bg_inode_table</td><td style="text-align:center">0x05</td><td style="text-align:center">inode区从5号块开始</td></tr></tbody></table></div><h3 id="数据区位图和inode位图-bitmap"><a href="#数据区位图和inode位图-bitmap" class="headerlink" title="数据区位图和inode位图(bitmap)"></a>数据区位图和inode位图(bitmap)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为数据块位图区（3号块）</span></span><br><span class="line"><span class="number">00000</span>c00  ff ff ff ff ff ff <span class="number">01</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line"><span class="number">00000</span>c10  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br><span class="line"><span class="comment">//以下为i节点位图区（4号块）</span></span><br><span class="line"><span class="number">00001000</span>  ff <span class="number">0f</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line"><span class="number">00001010</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line"><span class="number">00001020</span>  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">***</span><br></pre></td></tr></table></figure><h3 id="inode区"><a href="#inode区" class="headerlink" title="inode区"></a>inode区</h3><p>inode区从5号块开始，因此起始地址应该是0x400$\times{5}=$0x1400，查看此处数据。另外根目录的inode是定死的，位于inode区的第2个，地址就是0x1400+128$\times$2=0x1480（inode区的第一个inode没有意义）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为inode区（5号块）</span></span><br><span class="line"><span class="number">00001400</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br><span class="line"><span class="comment">//以下为2号i节点（i节点从1开始编号），即根目录的i节点</span></span><br><span class="line"><span class="number">00001480</span>  ed <span class="number">41</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">49</span> <span class="number">4</span>d <span class="number">9</span>e <span class="number">5</span>e <span class="number">46</span> <span class="number">4</span>a <span class="number">9</span>e <span class="number">5</span>e  |.A......IM.^FJ.^|</span><br><span class="line">                      ^_________^</span><br><span class="line">                      <span class="built_in">i_size</span>(bytes)</span><br><span class="line"><span class="number">00001490</span>  <span class="number">46</span> <span class="number">4</span>a <span class="number">9</span>e <span class="number">5</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |FJ.^............|</span><br><span class="line">                                               ^_________^</span><br><span class="line">                                                i_blocks</span><br><span class="line"><span class="number">000014</span>a0  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">25</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |........%.......|</span><br><span class="line">                                   ^_________^</span><br><span class="line">                                    i_block</span><br><span class="line"><span class="number">000014b</span>0  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br></pre></td></tr></table></figure></p><div class="table-container"><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">值</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">i_size</td><td style="text-align:center">0x0400</td><td style="text-align:center">文件大小0x400B=1KB</td></tr><tr><td style="text-align:center">i_blocks</td><td style="text-align:center">0x0002</td><td style="text-align:center">文件数据块数为2</td></tr><tr><td style="text-align:center">i_block</td><td style="text-align:center">0x0025</td><td style="text-align:center">第一个数据块的块号为37，偏移是0x400$\times$37=0x9400</td></tr></tbody></table></div><h3 id="根目录数据块"><a href="#根目录数据块" class="headerlink" title="根目录数据块"></a>根目录数据块</h3><p>在地址0x9400处查看根目录数据块中的内容，其中记录着目录项：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为根目录的第一个数据块</span></span><br><span class="line"><span class="number">00009400</span>  <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>c <span class="number">00</span> <span class="number">01</span> <span class="number">02</span>  <span class="number">2</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">          ^_________^ ^___^ ^^ ^^  ^_________^ ^_________^</span><br><span class="line">          inode       rec_len      name         inode</span><br><span class="line">                            ^name_len </span><br><span class="line">                               ^file_type      ^第<span class="number">2</span>个目录项</span><br><span class="line"><span class="number">00009410</span>  <span class="number">0</span>c <span class="number">00</span> <span class="number">02</span> <span class="number">02</span> <span class="number">2</span>e <span class="number">2</span>e <span class="number">00</span> <span class="number">00</span>  <span class="number">0b</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">14</span> <span class="number">00</span> <span class="number">0</span>a <span class="number">02</span>  |................|</span><br><span class="line">          ^___^ ^^ ^^ ^_________^  ^_________^ ^___^ ^^ ^^</span><br><span class="line">                                   ^第<span class="number">3</span>个目录项</span><br><span class="line"><span class="number">00009420</span>  <span class="number">6</span>c <span class="number">6f</span> <span class="number">73</span> <span class="number">74</span> <span class="number">2b</span> <span class="number">66</span> <span class="number">6f</span> <span class="number">75</span>  <span class="number">6</span>e <span class="number">64</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>c <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |lost+found......|</span><br><span class="line">          ^__________________________________^ ^_________^</span><br><span class="line">          ^文件名lost+found，末尾用\<span class="number">0</span>补充        ^第<span class="number">4</span>个目录项</span><br><span class="line"><span class="number">00009430</span>  d4 <span class="number">03</span> <span class="number">09</span> <span class="number">01</span> <span class="number">68</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c  <span class="number">6f</span> <span class="number">2</span>e <span class="number">74</span> <span class="number">78</span> <span class="number">74</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |....hello.txt...|</span><br><span class="line">          ^___^ ^^ ^^ ^__________________________________^</span><br><span class="line">                      ^名字hello.txt</span><br><span class="line"><span class="number">00009440</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br></pre></td></tr></table></figure></p><div class="table-container"><table><thead><tr><th style="text-align:center">inode号</th><th style="text-align:center">目录项长度</th><th style="text-align:center">文件名长度</th><th style="text-align:center">文件类型</th><th style="text-align:center">文件名</th></tr></thead><tbody><tr><td style="text-align:center">0x02</td><td style="text-align:center">0x0c: 12 Bytes</td><td style="text-align:center">0x1</td><td style="text-align:center">目录</td><td style="text-align:center">.</td></tr><tr><td style="text-align:center">0x02</td><td style="text-align:center">0x0c: 12 Bytes</td><td style="text-align:center">0x1</td><td style="text-align:center">目录</td><td style="text-align:center">..</td></tr><tr><td style="text-align:center">0x0b</td><td style="text-align:center">0x14: 20 Bytes</td><td style="text-align:center">0x0a: 10</td><td style="text-align:center">目录</td><td style="text-align:center">lost+found</td></tr><tr><td style="text-align:center">0x0c</td><td style="text-align:center">0x3d4 Bytes</td><td style="text-align:center">0x09</td><td style="text-align:center">普通文件</td><td style="text-align:center">hello.txt</td></tr></tbody></table></div><p>这是根目录下的目录项，注意到第1个和第2个目录项的inode号都是0x02号inode，指向根目录自己（打开当前目录和打开上一级目录都是指向自己）。此外hello.txt的inode号为0x0c，因此hello.txt的inode的地址为0x1400+0x80$\times$(0x0c-1)=0x1980，在此处查看hello.txt的inode信息。</p><h3 id="hello-txt的inode"><a href="#hello-txt的inode" class="headerlink" title="hello.txt的inode"></a>hello.txt的inode</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为hello.txt的i节点（12号）</span></span><br><span class="line"><span class="number">00001980</span>  a4 <span class="number">81</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">56</span> <span class="number">4</span>a <span class="number">9</span>e <span class="number">5</span>e <span class="number">46</span> <span class="number">4</span>a <span class="number">9</span>e <span class="number">5</span>e  |........VJ.^FJ.^|</span><br><span class="line"><span class="number">00001990</span>  <span class="number">46</span> <span class="number">4</span>a <span class="number">9</span>e <span class="number">5</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |FJ.^............|</span><br><span class="line"><span class="number">000019</span>a0  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">01</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">                                   ^_________^</span><br><span class="line">                                     i_block:第一个数据块号</span><br><span class="line"><span class="number">000019b</span>0  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br></pre></td></tr></table></figure><p>hello.txt的inode信息说明第一个数据块的块号为0x0201，对应偏移是0x400$\times$0x201=0x80400，查看该地址处的数据块的内容。</p><h3 id="hello-txt的数据块"><a href="#hello-txt的数据块" class="headerlink" title="hello.txt的数据块"></a>hello.txt的数据块</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为hello.txt的第一个数据块</span></span><br><span class="line"><span class="number">00080400</span>  <span class="number">48</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6f</span> <span class="number">2</span>c <span class="number">20</span> <span class="number">77</span>  <span class="number">6f</span> <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span> <span class="number">21</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">00</span>  |Hello, world!...|</span><br><span class="line"><span class="number">00080410</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br></pre></td></tr></table></figure><p>数据块中存储着hello.txt的ASCII码。</p><h3 id="lost-found的inode"><a href="#lost-found的inode" class="headerlink" title="lost+found的inode"></a>lost+found的inode</h3><p>根目录中lost+found目录的inode编号为0x0b，因此lost+found目录文件的inode地址为0x1400+0x80$\times$(0x0b-1)=0x1900，在此处查看lost+found的inode信息。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为lost+found的inode</span></span><br><span class="line"><span class="number">00001900</span>  ed <span class="number">41</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">30</span> <span class="number">00</span> <span class="number">00</span>  d7 <span class="number">49</span> <span class="number">9</span>e <span class="number">5</span>e d7 <span class="number">49</span> <span class="number">9</span>e <span class="number">5</span>e  |.A..<span class="number">.0</span>...I.^.I.^|</span><br><span class="line"><span class="number">00001910</span>  d7 <span class="number">49</span> <span class="number">9</span>e <span class="number">5</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">18</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |.I.^............|</span><br><span class="line"><span class="number">00001920</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">26</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">27</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |........&amp;..<span class="number">.&#x27;</span>...|</span><br><span class="line">                                   ^_________^ ^_________^</span><br><span class="line">                                     i_block     i_block</span><br><span class="line">                                 第一个数据块标号  第二个数据块标号</span><br><span class="line"><span class="number">00001930</span>  <span class="number">28</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">29</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">2</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">2b</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |(...)...*...+...|</span><br><span class="line"><span class="number">00001940</span>  <span class="number">2</span>c <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">2</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">2</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">2f</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |,...-......./...|</span><br><span class="line"><span class="number">00001950</span>  <span class="number">30</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">31</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |<span class="number">0.</span>.<span class="number">.1</span>...........|</span><br><span class="line"><span class="number">00001960</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br></pre></td></tr></table></figure><br>lost+found第一个数据块的块号为0x0026，对应偏移是0x400$\times$0x26=0x9800，查看该地址处的数据块的内容。</p><h3 id="lost-found数据块内容"><a href="#lost-found数据块内容" class="headerlink" title="lost+found数据块内容"></a>lost+found数据块内容</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为lost+found的目录项数据块</span></span><br><span class="line"><span class="number">00009800</span>  <span class="number">0b</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>c <span class="number">00</span> <span class="number">01</span> <span class="number">02</span>  <span class="number">2</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">          ^_________^ ^___^ ^^ ^^  ^_________^ ^_________^</span><br><span class="line">          inode       rec_len      name         inode</span><br><span class="line">                            ^name_len </span><br><span class="line">                               ^file_type      ^第<span class="number">2</span>个目录项</span><br><span class="line"><span class="number">00009810</span>  f4 <span class="number">03</span> <span class="number">02</span> <span class="number">02</span> <span class="number">2</span>e <span class="number">2</span>e <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">          ^___^ ^^ ^^ ^_________^</span><br><span class="line"><span class="number">00009820</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br><span class="line"><span class="number">00009</span>c00  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line"><span class="number">00009</span>c10  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  |................|</span><br><span class="line">***</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">inode号</th><th style="text-align:center">目录项长度</th><th style="text-align:center">文件名长度</th><th style="text-align:center">文件类型</th><th style="text-align:center">文件名</th></tr></thead><tbody><tr><td style="text-align:center">0x0b</td><td style="text-align:center">0x0c: 12 Bytes</td><td style="text-align:center">0x1</td><td style="text-align:center">目录</td><td style="text-align:center">.</td></tr><tr><td style="text-align:center">0x02</td><td style="text-align:center">0x03f4Bytes</td><td style="text-align:center">0x2</td><td style="text-align:center">目录</td><td style="text-align:center">..</td></tr></tbody></table></div><p>当前目录inode指向自己，而上一级目录指向根目录。</p>]]></content>
    
    
    <summary type="html">本篇为小王同学的第4篇操作系统知识：Linux的Ext2文件系统</summary>
    
    
    
    <category term="计算机基础知识" scheme="http://chudod.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="操作系统" scheme="http://chudod.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://chudod.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>English Sentences</title>
    <link href="http://chudod.github.io/2022/05/14/English_Sentences/"/>
    <id>http://chudod.github.io/2022/05/14/English_Sentences/</id>
    <published>2022-05-13T16:00:00.000Z</published>
    <updated>2022-05-14T14:43:10.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="国家和社会"><a href="#国家和社会" class="headerlink" title="国家和社会"></a>国家和社会</h1><p>1、Thus, jointly making contributions to Chinese Great Rejuvenation.<br>   为实现中华民族的伟大复兴而奋斗。</p><p>2、Humanity is an inexorable upward march.<br>   人类进步的脚步不可阻挡。</p><h1 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h1><p>1、The conventional education focuses on convergent thinking rather than divergent thinking.<br>   传统的教育关注聚合思维，而不是发散性思维。</p>]]></content>
    
    
    <summary type="html">常用的高逼格英语句子</summary>
    
    
    
    <category term="English" scheme="http://chudod.github.io/categories/English/"/>
    
    
    <category term="English Writing" scheme="http://chudod.github.io/tags/English-Writing/"/>
    
  </entry>
  
  <entry>
    <title>English Vocabulary</title>
    <link href="http://chudod.github.io/2022/05/11/English_Vocabulary/"/>
    <id>http://chudod.github.io/2022/05/11/English_Vocabulary/</id>
    <published>2022-05-10T16:00:00.000Z</published>
    <updated>2022-05-17T14:11:52.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="词根词缀"><a href="#词根词缀" class="headerlink" title="词根词缀"></a>词根词缀</h1><h2 id="1、vent"><a href="#1、vent" class="headerlink" title="1、vent"></a>1、vent</h2><pre class="mermaid">graph TDA(vent: to come)-->B1(advent 出现 到来)A-->B2(venture 投机活动)B2-->D1(joint venture 合资子公司)</pre><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="1、政治"><a href="#1、政治" class="headerlink" title="1、政治"></a>1、政治</h2><div class="table-container"><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">释义</th><th style="text-align:center">单词</th><th style="text-align:center">释义</th><th style="text-align:center">单词</th><th style="text-align:center">释义</th><th style="text-align:center">单词</th><th style="text-align:center">释义</th></tr></thead><tbody><tr><td style="text-align:center">constitution</td><td style="text-align:center">宪法</td><td style="text-align:center">corruption</td><td style="text-align:center">腐败</td><td style="text-align:center">bribery</td><td style="text-align:center">贿赂</td><td style="text-align:center">ethic</td><td style="text-align:center">道德</td></tr><tr><td style="text-align:center">ethnic minorities</td><td style="text-align:center">少数民族</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">常用的生活英语单词</summary>
    
    
    
    <category term="English" scheme="http://chudod.github.io/categories/English/"/>
    
    
    <category term="English Vocabulary" scheme="http://chudod.github.io/tags/English-Vocabulary/"/>
    
  </entry>
  
  <entry>
    <title>Русские Слова(俄语单词)</title>
    <link href="http://chudod.github.io/2022/05/11/Russian_Vocabulary/"/>
    <id>http://chudod.github.io/2022/05/11/Russian_Vocabulary/</id>
    <published>2022-05-10T16:00:00.000Z</published>
    <updated>2022-05-12T11:52:12.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h1><div class="table-container"><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">释义</th><th style="text-align:center">单词</th><th style="text-align:center">释义</th><th style="text-align:center">单词</th><th style="text-align:center">释义</th><th style="text-align:center">单词</th><th style="text-align:center">释义</th></tr></thead><tbody><tr><td style="text-align:center">один</td><td style="text-align:center">一</td><td style="text-align:center">два</td><td style="text-align:center">二</td><td style="text-align:center">три</td><td style="text-align:center">三</td><td style="text-align:center">четыре</td><td style="text-align:center">四</td></tr><tr><td style="text-align:center">бять</td><td style="text-align:center">五</td></tr></tbody></table></div><h1 id="国家"><a href="#国家" class="headerlink" title="国家"></a>国家</h1><div class="table-container"><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">释义</th><th style="text-align:center">单词</th><th style="text-align:center">释义</th><th style="text-align:center">单词</th><th style="text-align:center">释义</th><th style="text-align:center">单词</th><th style="text-align:center">释义</th></tr></thead><tbody><tr><td style="text-align:center">Китай</td><td style="text-align:center">中国</td><td style="text-align:center">Совецкий Союз</td><td style="text-align:center">苏联</td><td style="text-align:center">Россия(России)</td><td style="text-align:center">俄罗斯</td><td style="text-align:center"></td></tr></tbody></table></div><h1 id="人称"><a href="#人称" class="headerlink" title="人称"></a>人称</h1>]]></content>
    
    
    <summary type="html">该页面整理了常用的俄语单词。</summary>
    
    
    
    <category term="Россия" scheme="http://chudod.github.io/categories/%D0%A0%D0%BE%D1%81%D1%81%D0%B8%D1%8F/"/>
    
    
    <category term="Россия" scheme="http://chudod.github.io/tags/%D0%A0%D0%BE%D1%81%D1%81%D0%B8%D1%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux程序执行与进程创建</title>
    <link href="http://chudod.github.io/2022/05/06/OS_ELF_execve/"/>
    <id>http://chudod.github.io/2022/05/06/OS_ELF_execve/</id>
    <published>2022-05-05T16:00:00.000Z</published>
    <updated>2022-05-28T15:02:09.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、程序的编译与执行"><a href="#一、程序的编译与执行" class="headerlink" title="一、程序的编译与执行"></a>一、程序的编译与执行</h1><h2 id="Program-Header"><a href="#Program-Header" class="headerlink" title="Program Header"></a>Program Header</h2><p>通常，我们写的代码都是编译、链接一气呵成，直接生成可执行文件，并且程序编译出来的虚拟起始地址通常是0x08048000，操作系统做了很多工作。例如将program.c编译和链接成可运行的文件:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc program.c -o program</span><br></pre></td></tr></table></figure><br>这其中经过了编译和链接两个步骤：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc program.c -o program.o</span><br><span class="line">gcc program.o -o program</span><br></pre></td></tr></table></figure><br>得到的program.o只是一个待重定位文件，文件里面的符号（函数和变量）还没有安排地址，将来在链接的时候与其他文件“组合”成一个可执行文件时再重新定位（安排地址）。“组合”指的就是链接。因为在编译期间不知道会链接那些文件，所以干脆在链接的阶段一起编址，形成一个可重定位文件。<br>程序之间调用的最简单的方式是$\verb+call+$和$\verb+jmp+$，例如BIOS调用MBR以及MBR调用Loader，MBR的物理地址是0x7c00，而Loader的地址可以是0x900，通常事先约定好调用地址。这种方法非常不灵活，因此一种灵活的方法便是程序的入口地址信息与程序绑定，在程序文件中专门腾出一个空间来写程序的入口地址、程序的大小等等信息。原先的可执行二进制文件(program body)加上新的文件头(program header)，就形成了一种新的文件格式这种具有程序头文件格式的程序文件从外存读入内存中后，从该程序文件的头读出程序入口地址，跨过程序头，跳转到入口地址执行。</p><h2 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h2><h3 id="ELF文件格式整体视图"><a href="#ELF文件格式整体视图" class="headerlink" title="ELF文件格式整体视图"></a>ELF文件格式整体视图</h3><p>Windows系统下的可执行文件格式是PE（Portable Executable，exe是文件拓展名，不是真正的格式），而Linux的可执行文件格式是ELF(Executable and Linkable Format，可执行连接格式)。ELF文件是经过编译和链接之后，可以直接运行的二进制可执行文件。Linux中的.o文件和可执行二进制文件都是ELF格式的文件。ELF文件格式可以在/usr/include/elf.h中可以找到ELF文件格式的所有定义。<br>程序最重要的概念是段(segment)和节(section)，其中section是程序员在进行汇编程序设计时显示划分出的数据区、代码区、栈区等等，而不同程序在链接时，链接器将多个目标文件相同属性的section链接成一个segment，形成了可执行内存空间中的数据段、代码段等等。因此ELF格式重要有相应的数据结构来描述程序中不同的section和segment，一个段头(Program header，也叫程序头)用来描述一个段，一个节头(Section header)用来描述一个section，也就有了程序头表(Program header table，也可以称之为段头表)和节头表(Section header table)，本质就是用来分别存储段头和节头的两个数组。而程序头表和节头表的条目个数和表长也是不确定的，因此还需要另一个结构来描述程序头表和节头表，也就是ELF头(ELF Header)，因此整个ELF文件格式看起来如下图所示（图片来源：《操作系统真相还原》）。ELF文件格式真正的作用在链接和运行阶段，因此ELF文件格式布局也从这两方面展示。</p><p><head><br>    <meta charset="utf-8"></p><p><style><br>    .body{width:350px;height:200px}</style></p><p><h4 align="center">ELF文件格式视图</h4></p><table align="center" border="1" width="700px" cellspacing="7"><tr>    <td style="border: 1px solid black" align="center">链接视图</td>    <td style="border: 1px solid black" align="center">运行视图</td></tr><tr>    <td style="border: 1px solid black" align="center">ELF Header(elf头)</td>    <td style="border: 1px solid black" align="center">ELF Header(elf头)</td></tr><tr>    <td style="border: 1px solid black" align="center">Program Header Table(程序头表，非必须，可选)</td>    <td style="border: 1px solid black" align="center">Program Header Table(程序头表)</td></tr><tr>    <td style="border: 1px solid black" align="center">Section 1(节 1)</td>    <td style="border: 1px solid black" rowspan="2" align="center">Segment 1(段1)</td></tr><tr>    <td style="border: 1px solid black" align="center">...</th></tr><tr>    <td style="border: 1px solid black" align="center">...</th>    <td style="border: 1px solid black" rowspan="2" align="center">Segment 2(段2)</td></tr><tr>    <td style="border: 1px solid black" align="center">Section n(节 n)</th></tr><tr>    <td style="border: 1px solid black" align="center">...</th>    <td style="border: 1px solid black" align="center">...</th></tr><tr>    <td style="border: 1px solid black" align="center">Section Header Table(节头表)</td>    <td style="border: 1px solid black" align="center">Section Header Table(节头表，非必须，可选)</td></tr><tr>    <td style="border: 1px solid black" align="center">...</th>    <td style="border: 1px solid black" align="center">...</th></tr><tr>    <td class="body" style="border: 1px solid black" align="center">带重定位文件体(Program Body)</td>    <td class="body" style="border: 1px solid black" align="center">可执行文件体(Program Body)</td></tr></table><h3 id="ELF-Header数据结构"><a href="#ELF-Header数据结构" class="headerlink" title="ELF Header数据结构"></a>ELF Header数据结构</h3><p>ELF Header结构定义在/usr/include/elf.h中的$\verb+struct Elf32_Ehdr+$中，结构体定义如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>e_ident[EI_NIDENT];    <span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf32_Halfe_type;        <span class="comment">/* Object file type */</span></span><br><span class="line">  Elf32_Halfe_machine;        <span class="comment">/* Architecture */</span></span><br><span class="line">  Elf32_Worde_version;        <span class="comment">/* Object file version */</span></span><br><span class="line">  Elf32_Addr    e_entry;        <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf32_Off     e_phoff;        <span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf32_Off     e_shoff;        <span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf32_Worde_flags;        <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf32_Halfe_ehsize;        <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf32_Halfe_phentsize;    <span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf32_Halfe_phnum;        <span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf32_Halfe_shentsize;    <span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf32_Halfe_shnum;        <span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf32_Halfe_shstrndx;        <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><br>其中e_ident[16]是16字节大小的数组，用来表示魔数以及其他的信息，具体含义如下表所示。</p><p><head><br>    <meta charset="utf-8"></p><p><style><br>    .leftbody{width:300px;height:100px}<br>    .rightbody{width:400px;height:100px}</style></p><p><h4 align="center">e_ident[16]数组</h4></p><table align="center" border="1" width="700px" cellspacing="7"><tr>    <td style="border: 1px solid black" align="center">e_ident[]成员</td>    <td style="border: 1px solid black" align="center">意义</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[0] = 0x7f</td>    <td style="border: 1px solid black" rowspan="4" align="center">这4位是ELF文件的魔数(magic number)，表明这是一个ELF文件，e_ident[1]~e_ident[3]这3个变量表示‘E’、‘L’、‘F’这三个字符</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[1] = 'E'</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[2] = 'L'</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[3] = 'F'</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[4]</td>    <td style="border: 1px solid black" align="center">ELF文件类型，值为0表示不可识别，值为1表示32位elf文件，值2表示64位elf文件</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[5]</td>    <td style="border: 1px solid black" align="center">编码格式，值为0：非法编码，值为1：小端字节序LSB，值为2：大端字节序MSB</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[6]</td>    <td style="border: 1px solid black" align="center">版本信息，默认为1</td></tr><tr>    <td class="leftbody" style="border: 1px solid black" align="center">e_ident[7～15]</td>    <td class="rightbody" style="border: 1px solid black" align="center">保留位，初始化为0</td></tr></table><p>而$\verb+struct Elf32_Ehdr+$中的所有成员的定义如下：</p><p><head><br>    <meta charset="utf-8"></p><p><style><br>    .leftbody{width:200px;height:30px}<br>    .rightbody{width:500px;height:30px}</style></p><p><h4 align="center">struct Elf32_Ehdr成员定义</h4></p><table align="center" border="1" width="700px" cellspacing="7"><tr>    <td style="border: 1px solid black" align="center">e_ident[16]</td>    <td style="border: 1px solid black" align="center">魔数和其他信息</td></tr><tr>    <td style="border: 1px solid black" align="center">e_type</td>    <td style="border: 1px solid black" align="center">2字节，目标文件类型，值0：位置格式文件，值1：可重定位文件，值2：可执行文件，值3：动态共享目标文件，值4：core文件（程序崩溃时内存映像转储格式），其他值无需关注</td></tr><tr>    <td style="border: 1px solid black" align="center">e_machine</td>    <td style="border: 1px solid black" align="center">2字节，elf文件所属体系结构，值2：SPARC，值3：Intel 80386，值7：Intel 80860，值8：MPIS RS3000等等</td></tr><tr>    <td style="border: 1px solid black" align="center">e_version</td>    <td style="border: 1px solid black" align="center">4字节，版本信息</td></tr><tr>    <td style="border: 1px solid black" align="center">e_entry</td>    <td style="border: 1px solid black" align="center">4字节，操作系统运行该程序时，将控制权转交到的虚拟地址</td></tr><tr>    <td style="border: 1px solid black" align="center">e_phoff</td>    <td style="border: 1px solid black" align="center">4字节，程序头表(program header table)在文件内的字节偏移量，若没有程序头表，则该值为0</td></tr><tr>    <td style="border: 1px solid black" align="center">e_shoff</td>    <td style="border: 1px solid black" align="center">4字节，节头表(section header table)在文件内的字节偏移量，若没有节头表，则该值为0</td></tr><tr>    <td style="border: 1px solid black" align="center">e_flags</td>    <td style="border: 1px solid black" align="center">4字节，处理器相关的标志</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ehsize</td>    <td style="border: 1px solid black" align="center">2字节，elf header的字节大小</td></tr><tr>    <td style="border: 1px solid black" align="center">e_phentsize</td>    <td style="border: 1px solid black" align="center">2字节，程序头表(program header table)的每个条目(entry)的字节大小，该条目就是后面将要引出的struct Elf32_Phdr</td></tr><tr>    <td style="border: 1px solid black" align="center">e_phnum</td>    <td style="border: 1px solid black" align="center">2字节，程序头表(program header table)的条目(entry)个数，即程序中有多少个段</td></tr><tr>    <td style="border: 1px solid black" align="center">e_shentsize</td>    <td style="border: 1px solid black" align="center">2字节，节头表(section header table)的每个条目的字节大小</td></tr><tr>    <td style="border: 1px solid black" align="center">e_shnum</td>    <td style="border: 1px solid black" align="center">2字节，节头表(section header table)的条目个数</td></tr><tr>    <td class="leftbody" style="border: 1px solid black" align="center">e_shstrndx</td>    <td class="leftbody" style="border: 1px solid black" align="center">2字节，Section header string table在节头表中的索引</td></tr></table><p>接下来是程序头表中条目的数据结构，也就是用来描述各个段(segment)的信息，其结构体为$\verb+struct Elf32_Phdr+$，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Program segment header.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Wordp_type;<span class="comment">/* Segment type */</span></span><br><span class="line">  Elf32_Off    p_offset;<span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf32_Addrp_vaddr;<span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf32_Addrp_paddr;<span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf32_Wordp_filesz;<span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf32_Wordp_memsz;<span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf32_Wordp_flags;<span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf32_Wordp_align;<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure><br>结构体中的各个成员的信息如下表所示：</p><p><head><br>    <meta charset="utf-8"></p><p><style><br>    .leftbody{width:200px;height:30px}<br>    .rightbody{width:500px;height:30px}</style></p><p><h4 align="center">struct Elf32_Phdr成员定义</h4></p><table align="center" border="1" width="700px" cellspacing="7"><tr>    <td style="border: 1px solid black" align="center">p_type</td>    <td style="border: 1px solid black" align="center">4字节，表示程序中该段的类型，值1：可加载程序段，值2：动态链接信息，值3：动态加载器名称，值6：程序头表，以及其他无需关注的信息</td></tr><tr>    <td style="border: 1px solid black" align="center">p_offset</td>    <td style="border: 1px solid black" align="center">4字节，本段在文件内的起始偏移地址</td></tr><tr>    <td style="border: 1px solid black" align="center">p_vaddr</td>    <td style="border: 1px solid black" align="center">4字节，本段在内存中的起始虚拟地址</td></tr><tr>    <td style="border: 1px solid black" align="center">p_paddr</td>    <td style="border: 1px solid black" align="center">4字节，仅用于与物理地址相关的系统如System V中</td></tr><tr>    <td style="border: 1px solid black" align="center">p_filesz</td>    <td style="border: 1px solid black" align="center">4字节，本段在文件中的大小</td></tr><tr>    <td style="border: 1px solid black" align="center">p_memsz</td>    <td style="border: 1px solid black" align="center">4字节，本段在内存中的大小</td></tr><tr>    <td style="border: 1px solid black" align="center">p_flags</td>    <td style="border: 1px solid black" align="center">4字节，本段相关的标志，0b1：可执行，0b10：可写，0b100：可读，以及其他标志</td></tr><tr>    <td class="leftbody" style="border: 1px solid black" align="center">p_align</td>    <td class="rightbody" style="border: 1px solid black" align="center">4字节，本段在内存和文件中的对齐方式，若值为0或值1，则不对齐，否则其为2的幂次</td></tr></table><h3 id="实验程序实例"><a href="#实验程序实例" class="headerlink" title="实验程序实例"></a>实验程序实例</h3><p>一共两个程序，分别为parent.c和child.c，其中在parent.c中父进程会$\verb+fork+$一个子进程，子进程会利用$\verb+execve+$系统调用来将child.c加载进自己的进程空间，执行这一段新的程序。<br>这个是父进程执行的程序：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*parent.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str1[<span class="number">4096</span>] = &#123;<span class="string">&quot;String of parent process.\n&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)             <span class="comment">/*Error occured*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Fork failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)            <span class="comment">/*Child process*/</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str1);</span><br><span class="line">        <span class="built_in">strcpy</span>(str1, <span class="string">&quot;String of child process.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str1);</span><br><span class="line">        <span class="built_in">execve</span>(<span class="string">&quot;./child&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                    <span class="comment">/*Parent process*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str1, <span class="string">&quot;Running in parent process.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个是子进程加载的新程序：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*child.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str2[<span class="number">4096</span>] = &#123;<span class="string">&quot;Child process is runing another program!\n&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>* ptr2 = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(str2) + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(ptr2, <span class="number">0</span>, <span class="built_in">sizeof</span>(ptr2));</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr2, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, ptr2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ELF-Header实例"><a href="#ELF-Header实例" class="headerlink" title="ELF Header实例"></a>ELF Header实例</h3><p>可以利用xxd命令来查看ELF文件格式信息，新建一个xxd.sh脚本，其内容为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd -g <span class="number">1</span> -s $<span class="number">2</span> -l $<span class="number">3</span> $<span class="number">1</span></span><br></pre></td></tr></table></figure><br>然后在命令行中输入<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh ./xxd.sh ./child <span class="number">0</span> <span class="number">300</span></span><br></pre></td></tr></table></figure><br>即可查看child文件的ELF格式信息。上面参数的意思是查看0~300字节的ELF文件格式信息。在学校提供的实验平台上得到的结果如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span>: <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">01</span> <span class="number">01</span> <span class="number">01</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  .ELF............</span><br><span class="line"><span class="number">00000010</span>: <span class="number">02</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>a <span class="number">8</span>d <span class="number">04</span> <span class="number">08</span> <span class="number">34</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ...........<span class="number">.4</span>...</span><br><span class="line"><span class="number">00000020</span>: <span class="number">0</span>c <span class="number">34</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span> <span class="number">00</span> <span class="number">20</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">28</span> <span class="number">00</span>  <span class="number">.4</span>.....<span class="number">.4</span>. ...(.</span><br><span class="line"><span class="number">00000030</span>: <span class="number">24</span> <span class="number">00</span> <span class="number">21</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> <span class="number">04</span> <span class="number">08</span>  $.!.............</span><br><span class="line"><span class="number">00000040</span>: <span class="number">00</span> <span class="number">80</span> <span class="number">04</span> <span class="number">08</span> <span class="number">6f</span> <span class="number">00</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">6f</span> <span class="number">00</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ....o...o.......</span><br><span class="line"><span class="number">00000050</span>: <span class="number">00</span> <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">58</span> <span class="number">0f</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">58</span> <span class="number">9f</span> <span class="number">0</span>e <span class="number">08</span>  ........X...X...</span><br><span class="line"><span class="number">00000060</span>: <span class="number">58</span> <span class="number">9f</span> <span class="number">0</span>e <span class="number">08</span> <span class="number">48</span> <span class="number">20</span> <span class="number">00</span> <span class="number">00</span> cc <span class="number">33</span> <span class="number">00</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  X...H ..<span class="number">.3</span>......</span><br><span class="line"><span class="number">00000070</span>: <span class="number">00</span> <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> f4 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> f4 <span class="number">80</span> <span class="number">04</span> <span class="number">08</span>  ................</span><br><span class="line"><span class="number">00000080</span>: f4 <span class="number">80</span> <span class="number">04</span> <span class="number">08</span> <span class="number">44</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">44</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ....D...D.......</span><br><span class="line"><span class="number">00000090</span>: <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">58</span> <span class="number">0f</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">58</span> <span class="number">9f</span> <span class="number">0</span>e <span class="number">08</span>  ........X...X...</span><br><span class="line"><span class="number">000000</span>a0: <span class="number">58</span> <span class="number">9f</span> <span class="number">0</span>e <span class="number">08</span> <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">28</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  X.......(.......</span><br><span class="line"><span class="number">000000b</span>0: <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">51</span> e5 <span class="number">74</span> <span class="number">64</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ....Q.td........</span><br><span class="line"><span class="number">000000</span>c0: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................</span><br><span class="line"><span class="number">000000</span>d0: <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">52</span> e5 <span class="number">74</span> <span class="number">64</span> <span class="number">58</span> <span class="number">0f</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">58</span> <span class="number">9f</span> <span class="number">0</span>e <span class="number">08</span>  ....R.tdX...X...</span><br><span class="line"><span class="number">000000e0</span>: <span class="number">58</span> <span class="number">9f</span> <span class="number">0</span>e <span class="number">08</span> a8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> a8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  X...............</span><br><span class="line"><span class="number">000000f</span>0: <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................</span><br><span class="line"><span class="number">00000100</span>: <span class="number">47</span> <span class="number">4</span>e <span class="number">55</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  GNU.............</span><br><span class="line"><span class="number">00000110</span>: <span class="number">18</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">14</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................</span><br><span class="line"><span class="number">00000120</span>: <span class="number">47</span> <span class="number">4</span>e <span class="number">55</span> <span class="number">00</span> d9 <span class="number">5</span>e <span class="number">23</span> cf b2 <span class="number">2</span>c <span class="number">61</span> f1              GNU..^#..,a.</span><br></pre></td></tr></table></figure><br>因此child文件的ELF格式信息具体含义如下，其中0x00到0x33号内存单元是ELF Header(即$\verb+struct Elf+$)的内容，0x34到0xf4为program header(即$\verb+struct Elf32_Phdr+$)得内容，首先分析ELF Header信息：</p><p><head><br>    <meta charset="utf-8"></p><p><style><br>    .leftbody{width:150px;height:30px}<br>    .midbody{width:150;height:300}<br>    .rightbody{width:400px;height:30px}</style></p><p><h4 align="center">child文件的ELF Header信息</h4></p><table align="center" border="1" width="700px" cellspacing="7"><tr>    <td style="border: 1px solid black" align="center">成员</td>    <td style="border: 1px solid black" align="center">值</td>    <td style="border: 1px solid black" align="center">含义</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[4]</td>    <td style="border: 1px solid black" align="center">0x01</td>    <td style="border: 1px solid black" align="center">32位的elf文件</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ident[5]</td>    <td style="border: 1px solid black" align="center">0x01</td>    <td style="border: 1px solid black" align="center">小端字节序</td></tr><tr>    <td style="border: 1px solid black" align="center">e_type</td>    <td style="border: 1px solid black" align="center">0x0002</td>    <td style="border: 1px solid black" align="center">可执行文件</td></tr><tr>    <td style="border: 1px solid black" align="center">e_machine</td>    <td style="border: 1px solid black" align="center">0x0003</td>    <td style="border: 1px solid black" align="center">intel 80386平台</td></tr><tr>    <td style="border: 1px solid black" align="center">e_entry</td>    <td style="border: 1px solid black" align="center">0x08048d0a</td>    <td style="border: 1px solid black" align="center">程序的虚拟入口地址为0x08048d0a</td></tr><tr>    <td style="border: 1px solid black" align="center">e_phoff</td>    <td style="border: 1px solid black" align="center">0x00000034</td>    <td style="border: 1px solid black" align="center">程序头表在文件中的偏移量是0x34</td></tr><tr>    <td style="border: 1px solid black" align="center">e_shoff</td>    <td style="border: 1px solid black" align="center">0x000a340c</td>    <td style="border: 1px solid black" align="center">节头表在文件中的偏移量</td></tr><tr>    <td style="border: 1px solid black" align="center">e_ehsize</td>    <td style="border: 1px solid black" align="center">0x0034</td>    <td style="border: 1px solid black" align="center">elf header大小为0x34，可见程序头表后面跟着elf头</td></tr><tr>    <td style="border: 1px solid black" align="center">e_phentsize</td>    <td style="border: 1px solid black" align="center">0x0020</td>    <td style="border: 1px solid black" align="center">程序头表program header每个条目(struct Elf32_Phdr)的大小为0x20</td></tr><tr>    <td style="border: 1px solid black" align="center">e_phnum</td>    <td style="border: 1px solid black" align="center">0x0006</td>    <td style="border: 1px solid black" align="center">程序头表中的元素个数为6，即有6个段</td></tr><tr>    <td style="border: 1px solid black" align="center">e_shentsize</td>    <td style="border: 1px solid black" align="center">0x0028</td>    <td style="border: 1px solid black" align="center">节头表中各个节的大小</td></tr><tr>    <td style="border: 1px solid black" align="center">e_shnum</td>    <td style="border: 1px solid black" align="center">0x0024</td>    <td style="border: 1px solid black" align="center">节头表中元素个数，说明一共0x24=36个节</td></tr><tr>    <td class="leftbody" style="border: 1px solid black" align="center">e_shstrndx</td>    <td class="midbody" style="border: 1px solid black" align="center">0x0021</td>    <td class="rightbody" style="border: 1px solid black" align="center">string name table在节头表中的索引为0x21</td></tr></table><p>然后分析程序头表program header的内容(第4行的0x34开始)，刚才ELF Header中可以知道，程序一共有6个段，且每个段的条目的大小为0x20。</p><p><head><br>    <meta charset="utf-8"></p><p><style><br>    .leftbody{width:150px;height:30px}<br>    .midbody{width:150;height:300}<br>    .rightbody{width:400px;height:30px}</style></p><p><h4 align="center">child文件的Program Header信息</h4></p><table align="center" border="1" width="700px" cellspacing="7"><tr>    <td style="border: 1px solid black" align="center">成员</td>    <td style="border: 1px solid black" align="center">值</td>    <td style="border: 1px solid black" align="center">含义</td></tr><tr>    <td style="border: 1px solid black" align="center">p_type</td>    <td style="border: 1px solid black" align="center">0x00000001</td>    <td style="border: 1px solid black" align="center">该程序为可加载程序段</td></tr><tr>    <td style="border: 1px solid black" align="center">p_offset</td>    <td style="border: 1px solid black" align="center">0x00000000</td>    <td style="border: 1px solid black" align="center">本段在文件内的偏移量为0x00</td></tr><tr>    <td style="border: 1px solid black" align="center">p_vaddr</td>    <td style="border: 1px solid black" align="center">0x08048000</td>    <td style="border: 1px solid black" align="center">该段被加载到内存后的起始虚拟地址！Elf Header中的e_entry是整个程序的入口地址(0x08048d0a)，而整个程序的起始地址是0x08048000。</td></tr><tr>    <td style="border: 1px solid black" align="center">p_paddr</td>    <td style="border: 1px solid black" align="center">0x08048000</td>    <td style="border: 1px solid black" align="center">和p_vaddr相似，不用管这个</td></tr><tr>    <td style="border: 1px solid black" align="center">p_filesz</td>    <td style="border: 1px solid black" align="center">0x000a006f</td>    <td style="border: 1px solid black" align="center">本段在文件中的字节大小</td></tr><tr>    <td style="border: 1px solid black" align="center">p_memsz</td>    <td style="border: 1px solid black" align="center">0x000a006f</td>    <td style="border: 1px solid black" align="center">本段在内存中的字节大小，等于p_filesz</td></tr><tr>    <td style="border: 1px solid black" align="center">p_flags</td>    <td style="border: 1px solid black" align="center">0x00000005</td>    <td style="border: 1px solid black" align="center">5=4+1，因此该段可读可执行，据此推测出该段应该是代码段。</td></tr><tr>    <td class="leftbody" style="border: 1px solid black" align="center">p_align</td>    <td class="midbody" style="border: 1px solid black" align="center">0x00001000</td>    <td class="rightbody" style="border: 1px solid black" align="center">本段的对齐方式为32字节对齐</td></tr></table><p>接下来看数据段的信息，在gdb调试窗口中打印str2的地址，为0x80ea080，并且数据段线性区的地址范围为0x80e9000到0x80ec000。<br>除了利用xxd命令查看ELF文件格式外，还可以利用readelf命令来查看。简单的输入：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -e child</span><br></pre></td></tr></table></figure><br>即可得到如下信息：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">01</span> <span class="number">01</span> <span class="number">01</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              <span class="number">2&#x27;</span>s complement, little endian</span><br><span class="line">  Version:                           <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - GNU</span><br><span class="line">  ABI Version:                       <span class="number">0</span></span><br><span class="line">  Type:                              <span class="built_in">EXEC</span> (Executable file)</span><br><span class="line">  Machine:                           Intel <span class="number">80386</span></span><br><span class="line">  Version:                           <span class="number">0x1</span></span><br><span class="line">  Entry point address:               <span class="number">0x8048d0a</span></span><br><span class="line">  Start of program headers:          <span class="number">52</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">668684</span> (bytes into file)</span><br><span class="line">  Flags:                             <span class="number">0x0</span></span><br><span class="line">  Size of <span class="keyword">this</span> header:               <span class="number">52</span> (bytes)</span><br><span class="line">  Size of program headers:           <span class="number">32</span> (bytes)</span><br><span class="line">  Number of program headers:         <span class="number">6</span></span><br><span class="line">  Size of section headers:           <span class="number">40</span> (bytes)</span><br><span class="line">  Number of section headers:         <span class="number">36</span></span><br><span class="line">  Section header string table index: <span class="number">33</span></span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>            <span class="number">00000000</span> <span class="number">000000</span> <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .note.ABI-tag     NOTE            <span class="number">080480f</span>4 <span class="number">0000f</span>4 <span class="number">000020</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">2</span>] .note.gnu.build-i NOTE            <span class="number">08048114</span> <span class="number">000114</span> <span class="number">000024</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">3</span>] .rel.plt          REL             <span class="number">08048138</span> <span class="number">000138</span> <span class="number">000070</span> <span class="number">08</span>   A  <span class="number">0</span>   <span class="number">5</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .init             PROGBITS        <span class="number">080481</span>a8 <span class="number">0001</span>a8 <span class="number">000023</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .plt              PROGBITS        <span class="number">080481</span>d0 <span class="number">0001</span>d0 <span class="number">0000e0</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span> <span class="number">16</span></span><br><span class="line">  [ <span class="number">6</span>] .text             PROGBITS        <span class="number">080482b</span>0 <span class="number">0002b</span>0 <span class="number">075134</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span> <span class="number">16</span></span><br><span class="line">  [ <span class="number">7</span>] __libc_freeres_fn PROGBITS        <span class="number">080b</span>d3f0 <span class="number">0753f</span>0 <span class="number">000</span>ad6 <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span> <span class="number">16</span></span><br><span class="line">  [ <span class="number">8</span>] __libc_thread_fre PROGBITS        <span class="number">080b</span>ded0 <span class="number">075</span>ed0 <span class="number">00006f</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span> <span class="number">16</span></span><br><span class="line">  [ <span class="number">9</span>] .fini             PROGBITS        <span class="number">080b</span>df40 <span class="number">075f</span>40 <span class="number">000014</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">10</span>] .rodata           PROGBITS        <span class="number">080b</span>df60 <span class="number">075f</span>60 <span class="number">01b</span>f90 <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span> <span class="number">32</span></span><br><span class="line">  [<span class="number">11</span>] __libc_subfreeres PROGBITS        <span class="number">080</span>d9ef0 <span class="number">091</span>ef0 <span class="number">00002</span>c <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">12</span>] __libc_atexit     PROGBITS        <span class="number">080</span>d9f1c <span class="number">091f</span>1c <span class="number">000004</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">13</span>] __libc_thread_sub PROGBITS        <span class="number">080</span>d9f20 <span class="number">091f</span>20 <span class="number">000004</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">14</span>] .eh_frame         PROGBITS        <span class="number">080</span>d9f24 <span class="number">091f</span>24 <span class="number">00e0</span>a8 <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">15</span>] .gcc_except_table PROGBITS        <span class="number">080e7</span>fcc <span class="number">09f</span>fcc <span class="number">0000</span>a3 <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">16</span>] .tdata            PROGBITS        <span class="number">080e9</span>f58 <span class="number">0</span>a0f58 <span class="number">000010</span> <span class="number">00</span> WAT  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">17</span>] .tbss             NOBITS          <span class="number">080e9</span>f68 <span class="number">0</span>a0f68 <span class="number">000018</span> <span class="number">00</span> WAT  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">18</span>] .init_array       INIT_ARRAY      <span class="number">080e9</span>f68 <span class="number">0</span>a0f68 <span class="number">000008</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">19</span>] .fini_array       FINI_ARRAY      <span class="number">080e9</span>f70 <span class="number">0</span>a0f70 <span class="number">000008</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">20</span>] .jcr              PROGBITS        <span class="number">080e9</span>f78 <span class="number">0</span>a0f78 <span class="number">000004</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">21</span>] .data.rel.ro      PROGBITS        <span class="number">080e9</span>f80 <span class="number">0</span>a0f80 <span class="number">000070</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span> <span class="number">32</span></span><br><span class="line">  [<span class="number">22</span>] .got              PROGBITS        <span class="number">080e9</span>ff0 <span class="number">0</span>a0ff0 <span class="number">000008</span> <span class="number">04</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">23</span>] .got.plt          PROGBITS        <span class="number">080</span>ea000 <span class="number">0</span>a1000 <span class="number">000044</span> <span class="number">04</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">24</span>] .data             PROGBITS        <span class="number">080</span>ea060 <span class="number">0</span>a1060 <span class="number">001f</span>40 <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span> <span class="number">32</span></span><br><span class="line">  [<span class="number">25</span>] .bss              NOBITS          <span class="number">080</span>ebfa0 <span class="number">0</span>a2fa0 <span class="number">00136</span>c <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span> <span class="number">32</span></span><br><span class="line">  [<span class="number">26</span>] __libc_freeres_pt NOBITS          <span class="number">080</span>ed30c <span class="number">0</span>a2fa0 <span class="number">000018</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">27</span>] .comment          PROGBITS        <span class="number">00000000</span> <span class="number">0</span>a2fa0 <span class="number">00002b</span> <span class="number">01</span>  MS  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">28</span>] .debug_aranges    PROGBITS        <span class="number">00000000</span> <span class="number">0</span>a2fcb <span class="number">000020</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">29</span>] .debug_info       PROGBITS        <span class="number">00000000</span> <span class="number">0</span>a2feb <span class="number">0000</span>dd <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">30</span>] .debug_abbrev     PROGBITS        <span class="number">00000000</span> <span class="number">0</span>a30c8 <span class="number">0000</span>a0 <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">31</span>] .debug_line       PROGBITS        <span class="number">00000000</span> <span class="number">0</span>a3168 <span class="number">00004</span>d <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">32</span>] .debug_str        PROGBITS        <span class="number">00000000</span> <span class="number">0</span>a31b5 <span class="number">0000</span>cb <span class="number">01</span>  MS  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">33</span>] .shstrtab         STRTAB          <span class="number">00000000</span> <span class="number">0</span>a3280 <span class="number">00018</span>c <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">34</span>] .symtab           SYMTAB          <span class="number">00000000</span> <span class="number">0</span>a39ac <span class="number">008</span>c00 <span class="number">10</span>     <span class="number">35</span> <span class="number">1060</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">35</span>] .strtab           STRTAB          <span class="number">00000000</span> <span class="number">0</span>ac5ac <span class="number">007</span>ebd <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  <span class="built_in">W</span> (write), <span class="built_in">A</span> (alloc), <span class="built_in">X</span> (execute), <span class="built_in">M</span> (merge), <span class="built_in">S</span> (strings)</span><br><span class="line">  <span class="built_in">I</span> (info), <span class="built_in">L</span> (link order), <span class="built_in">G</span> (group), <span class="built_in">T</span> (TLS), <span class="built_in">E</span> (exclude), <span class="built_in">x</span> (unknown)</span><br><span class="line">  <span class="built_in">O</span> (extra OS processing required) <span class="built_in">o</span> (OS specific), <span class="built_in">p</span> (processor specific)</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line">  LOAD           <span class="number">0x000000</span> <span class="number">0x08048000</span> <span class="number">0x08048000</span> <span class="number">0xa006f</span> <span class="number">0xa006f</span> R E <span class="number">0x1000</span></span><br><span class="line">  LOAD           <span class="number">0x0a0f58</span> <span class="number">0x080e9f58</span> <span class="number">0x080e9f58</span> <span class="number">0x02048</span> <span class="number">0x033cc</span> RW  <span class="number">0x1000</span></span><br><span class="line">  NOTE           <span class="number">0x0000f4</span> <span class="number">0x080480f4</span> <span class="number">0x080480f4</span> <span class="number">0x00044</span> <span class="number">0x00044</span> R   <span class="number">0x4</span></span><br><span class="line">  TLS            <span class="number">0x0a0f58</span> <span class="number">0x080e9f58</span> <span class="number">0x080e9f58</span> <span class="number">0x00010</span> <span class="number">0x00028</span> R   <span class="number">0x4</span></span><br><span class="line">  GNU_STACK      <span class="number">0x000000</span> <span class="number">0x00000000</span> <span class="number">0x00000000</span> <span class="number">0x00000</span> <span class="number">0x00000</span> RW  <span class="number">0x10</span></span><br><span class="line">  GNU_RELRO      <span class="number">0x0a0f58</span> <span class="number">0x080e9f58</span> <span class="number">0x080e9f58</span> <span class="number">0x000a8</span> <span class="number">0x000a8</span> R   <span class="number">0x1</span></span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   <span class="number">00</span>     .note.ABI-tag .note.gnu.build-id .rel.plt .init .plt .text __libc_freeres_fn __libc_thread_freeres_fn .fini .rodata __libc_subfreeres __libc_atexit __libc_thread_subfreeres .eh_frame .gcc_except_table</span><br><span class="line">   <span class="number">01</span>     .tdata .init_array .fini_array .jcr .data.rel.ro .got .got.plt .data .bss __libc_freeres_ptrs</span><br><span class="line">   <span class="number">02</span>     .note.ABI-tag .note.gnu.build-id</span><br><span class="line">   <span class="number">03</span>     .tdata .tbss</span><br><span class="line">   <span class="number">04</span></span><br><span class="line">   <span class="number">05</span>     .tdata .init_array .fini_array .jcr .data.rel.ro .got</span><br></pre></td></tr></table></figure><br>上面包含了ELF Header，所有Program Header以及Section Header的信息，最后还指明了每个section会整合进哪一个segment中，可以看到数据段应该是第2个segment。</p><h1 id="进程的创建与程序加载"><a href="#进程的创建与程序加载" class="headerlink" title="进程的创建与程序加载"></a>进程的创建与程序加载</h1><h2 id="整体视图"><a href="#整体视图" class="headerlink" title="整体视图"></a>整体视图</h2><p>在shell终端输入./parent，shell进程会调用fork()和execve()来创建新进程并加载./parent文件映像到父进程空间，然后parent进程又会同样调用fork()和execve()来创建新进程并加载./child文件映像到子进程空间。</p><p><div style = "align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB680b0b8f4b6098490039e8f6a025de95?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="40%" height="40%"/> </p><h2 id="Fork系统调用"><a href="#Fork系统调用" class="headerlink" title="Fork系统调用"></a>Fork系统调用</h2><p>fork函数的原型是$\verb+pid_t fork(void)+$，返回值有3种：子进程pid、0、-1。如果fork失败，那么返回-1。为了让父进程知道自己创建的子进程号，fork会给父进程返回子进程的pid，并且没有pid为0的的进程，因此fork给子进程返回0，通过返回值将父子进程区分开。调用fork之后，子进程会完全拷贝父进程的地址空间，因此两份进程的代码是一样的，只不过子进程是在fork系统调用才开始执行代码的，两者在$if$语句分道扬镳，就像一个叉子一样。<br>在Unix系统中提供了3种创建进程相关的系统调用: fork、vfork和clone，三种系统调用的区别如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">系统调用</th><th style="text-align:center">区别</th></tr></thead><tbody><tr><td style="text-align:center">fork</td><td style="text-align:center">无参数，子进程是父进程完整拷贝：复制父进程所有资源包括地址空间(mm_struct:包含指向页目录表和页表的指针)、页表、打开文件表、信号处理等，新版内核增加了写时复制COW，fork的代价仅剩拷贝父进程页表</td></tr><tr><td style="text-align:center">vfork</td><td style="text-align:center">无参数，父子进程共享地址空间：同一个mm_struct，无需复制，子进程完全运行在父进程的地址空间上，因此子进程修改变量，父进程的变量也会改变。为防止父进程重写子进程需要的数据，阻塞父进程执行，直到子进程退出或者使用exec加载新的程序</td></tr><tr><td style="text-align:center">clone</td><td style="text-align:center">有参数，父进程的资源有选择性的拷贝给子进程：clone_flags参数共享哪些资源，其余资源进行复制</td></tr></tbody></table></div><p>在调用fork系统调用时，创建的新任务具有父进程的所有相关数据的副本，更高版本的内核增加了写时复制(Copy On Write)，父子进程共享一组资源，例如数据段，设置为只读，如果子进程修改了数据段中的变量，数据段中的内容拷贝到新的内存中再进行修改，因此子进程对变量修改不会影响父进程。调用clone系统调用时，创建的新任务并不具有所有数据的拷贝，clone_flags参数决定共享哪些资源，例如$\verb+CLONE_VM+$决定共享相同的内存空间，$\verb+CLONE_FILES+$决定共享相同的打开文件。如果不设置这些参数，那么clone与fork功能类似。在内核中三种函数的执行流程如下：</p><p><div style = "align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBc958d4e5ba53bf36d8f1c91908b8483c?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="40%" height="40%"/>  </p><ul><li>注：在Linux中fork()利用clone()来实现，在C程序中调用fork()函数会触发120号系统调用clone，不会触发2号系统调用fork！我猜应该是Linux中采用了写时复制技术，很多资源父子进程共享，所以不用全部拷贝，部份拷贝，其余资源共享即可，所以用clone系统调用。（以上过程在i386-32位平台上实现）</li></ul><p>因此，parent.c程序中执行fork和execve系统调用时，数据段中的str1字符串发生的改变如下：<br>1、刚进入main函数，父进程指向str1所在物理页面，且页面可写；</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB220b71cadf3b1b5bac4278836e4a0316?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/>  </p><p>2、fork()函数执行后，父子进程共同指向str1物理页面，且页面只读；</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB3721974e0a188301cfda36c6af2c619f?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/>  </p><p>3、子进程试图修改str1的内容，发生写时复制，str1拷贝到新内存区域防止篡改父进程数据；</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB57c257d4ead121d8bc11a07729ae3391?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> </p><p>4、执行execve后子进程的mm_struct以及页目录项、页表项全部改变；</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBbf788e3c7683fe13a889e12fcb327420?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> </p><p>如果将C程序中的fork()改为vfork()，则父子进程的mm_struct、页目录和页表项均共享，可以直接篡改对方进程的数据：</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBeba8d4cdae87b5cff22f3f2d04def660?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> </p><h2 id="Execve系统调用"><a href="#Execve系统调用" class="headerlink" title="Execve系统调用"></a>Execve系统调用</h2><p>execve()函数是exec函数家族的一员，exec函数簇的6个函数功能类似，差别在于程序变量的表示方式和是否传入环境变量。exec会将可执行文件的绝对路径作为参数，把当前正在运行的用户的进程体（代码段、数据段、堆、栈、）用该可执行文件的进程体替换。<br>在shell终端输入一个可执行程序的文件名，shell程序会先用fork系统调用创建子进程，然后再调用execve系统调用，利用新的可执行文件的进程体替换fork出来的子进程的进程体，从而实现新进程执行完全不一样的新程序。<br>execve函数定义如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><br>三个参数分别是是可执行文件名、命令行参数和环境变量。execve()函数执行的主要轨迹如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">execve</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sys_execve</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">do_execve</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">do_execveat_common</span>()                        <span class="comment">//完成struct linux_binprm bprm初始化</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">load_elf_binary</span>()</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">load_elf_phdrs</span>();                   <span class="comment">//读取所有的程序头</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; e_phnum; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e_type != PT_LOAD) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="built_in">elf_map</span>();            <span class="comment">//mmap代码段和数据段，并建立用户进程到文件页高速缓存</span></span><br><span class="line">                    &#125;                         <span class="comment">//的映射关系，同时创建vm_area_struct</span></span><br><span class="line">                    <span class="built_in">start_thread</span>()</span><br><span class="line">                    &#123;</span><br><span class="line">                        regs-&gt;ip = new_ip;              <span class="comment">//入口地址设置为elf header中的e_entry</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><br>exec函数簇的6个函数最终都会执行execve()系统调用，在sys_execve()服务例程中，do_execve()函数调用do_execveat_common()来完成结构体$\verb+struct linux_binprm bprm+$的初始化，用来记录可执行文件的信息。该函数还会调用path_look_up()和dentry_open()获得可执行文件相关的目录项对象、文件对象和inode对象（《深入理解Linux内核》），执行完该函数后，进入load_elf_binary()函数之前，$\verb+struct linux_binprm bprm+$中的内容如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  buf = <span class="string">&quot;\177ELF\001\001\001\003\000\000\000\000\000\000\000\000\002\000\003\000\001</span></span><br><span class="line"><span class="string">  \000\000\000\n\215\004\b4\000\000\000\f4\n\000\000\000\000\000\064\000 \000\006\000</span></span><br><span class="line"><span class="string">  (\000$\000!\000\001\000\000\000\000\000\000\000\000\200\004\b\000\200\004\bo\000\n</span></span><br><span class="line"><span class="string">  \000o\000\n\000\005\000\000\000\000\020\000\000\001\000\000\000X\017\n\000X\237\016</span></span><br><span class="line"><span class="string">  \bX\237\016\bH\000\000\314\063\000\000\006\000\000\000\000\020\000\000\004\000\000</span></span><br><span class="line"><span class="string">  \000\364\000\000\000\364\200\004\b&quot;</span>, vma = <span class="number">0xc011c528</span>,</span><br><span class="line">  vma_pages = <span class="number">2</span>, mm = <span class="number">0xc5cc7a40</span>, p = <span class="number">3221225460</span>, cred_prepared = <span class="number">1</span>,</span><br><span class="line">  cap_effective = <span class="number">1</span>, recursion_depth = <span class="number">1</span>, file = <span class="number">0xc7542300</span>,</span><br><span class="line">  cred = <span class="number">0xc6393640</span>, unsafe = <span class="number">0</span>, per_clear = <span class="number">0</span>, argc = <span class="number">0</span>, envc = <span class="number">0</span>,</span><br><span class="line">  filename = <span class="number">0xc75353d0</span> <span class="string">&quot;./child&quot;</span>, interp = <span class="number">0xc75353d0</span> <span class="string">&quot;./child&quot;</span>,</span><br><span class="line">  interp_flags = <span class="number">0</span>, interp_data = <span class="number">0</span>, loader = <span class="number">0</span>, exec = <span class="number">3221225460</span>&#125;</span><br></pre></td></tr></table></figure><br>其中buf为128字节，这些字节包含的是ELF文件格式的魔数和其他信息（即ELF Header），用八进制表示，可以看到开头的’\177ELF’就是前面说到的ELF Header的开头几个魔数。并且此时的vma(vm_area_Struct)和mm(mm_struct)已经分配好了但是还没有初始化，将来会用新的mm和vma来替换当前的mm和vma。会在接下来的load_elf_binary()函数中完成该过程。<br>此时内存的情况如下所示：</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBa0ad675812fc28302e56120229572181?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> </p><p>load_elf_binary()函数为可执行文件的接口，执行的过程如下：</p><ul><li>1、动态创建一个结构体：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> </span><br><span class="line"> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">elfhdr</span> elf_ex;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">elfhdr</span> interp_elf_ex;</span><br><span class="line"> &#125; *loc;</span><br></pre></td></tr></table></figure>然后从传入参数的bprm-&gt;buf中获得elf header的信息，并进行校验：魔数必须匹配，程序的类型必须为ET_EXEC或者ET_DYN，检查bprm-&gt;file-&gt;f_op-&gt;mmap，指向的文件是否已经映射到内存中；</li><li>2、查找解释器段<br>遍历所有程序头（一共6个），通过遍历每个段，找到PT_INTERP类型段，也即是解释器段，找到说明需要运行过程中的动态链接。“解释器”段实际上只是一个字符串，即解释器的文件名，最终记录在elf_interpreter变量中。另外child程序是静态编译的程序，不需要动态链接，也就没有解析器段。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">elf_phdata = <span class="built_in">load_elf_phdrs</span>(&amp;loc-&gt;elf_ex, bprm-&gt;file);</span><br><span class="line">elf_ppnt = elf_phdata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loc-&gt;elf_ex.e_phnum; i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (elf_ppnt-&gt;p_type == PT_INTERP) </span><br><span class="line">      &#123;</span><br><span class="line">          ...</span><br><span class="line">elf_interpreter = <span class="built_in">kmalloc</span>(elf_ppnt-&gt;p_filesz, GFP_KERNEL);</span><br><span class="line">          <span class="comment">//根据其位置的p_offset和大小p_filesz把整个&quot;解释器&quot;段的内容读入缓冲区</span></span><br><span class="line"><span class="built_in">kernel_read</span>(bprm-&gt;file, elf_ppnt-&gt;p_offset, elf_interpreter,elf_ppnt-&gt;p_filesz);</span><br><span class="line">          <span class="comment">//struct *file类型的interpreter指针指向解释器段</span></span><br><span class="line">interpreter = <span class="built_in">open_exec</span>(elf_interpreter);</span><br><span class="line">          <span class="comment">//读入其开头的128个字节，即解释器文件的elf头部。</span></span><br><span class="line">          <span class="built_in">kernel_read</span>(interpreter, <span class="number">0</span>, (<span class="type">void</span>*)&amp;loc-&gt;interp_elf_ex, <span class="built_in">sizeof</span>(loc-&gt;interp_elf_ex));</span><br><span class="line">          ...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">elf_ppnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>3、清除前一个计算的所有资源，并分配新资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">flush_old_exec</span>(bprm);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">setup_new_exec</span>(bprm);</span><br></pre></td></tr></table></figure></li><li><p>4、设置栈段<br>检查所有的程序段，如果某一个段的类型为PT_GNU_STACK，即栈段，那么检查标志并设定相应的值，然后调用setup_arg_pages()函数利用do_execve()生成的参数页面的信息，来设定本程序$\verb+struct linux_binprm bprm+$的栈顶地址，然后mm-&gt;start_stack = bprm-&gt;p,将mm的栈的起始地址设定为bprm中栈顶指针指向的位置。</p></li></ul><p>跳过中间一些处理器相关的检查操作，直接来到ELF段载入阶段</p><ul><li><p>5、加载目标程序必须的段，即将ELF文件中的映像载入内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>, elf_ppnt = elf_phdata; i &lt; loc-&gt;elf_ex.e_phnum; i++, elf_ppnt++) </span><br><span class="line">  &#123;</span><br><span class="line"><span class="type">int</span> elf_prot = <span class="number">0</span>, elf_flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> k, vaddr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> total_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//搜索PT_LOAD段，也就是需要加载的段，只有代码段和数据段需要装入</span></span><br><span class="line"><span class="keyword">if</span> (elf_ppnt-&gt;p_type != PT_LOAD)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//检查标志、页面信息</span></span><br><span class="line"><span class="keyword">if</span> (elf_ppnt-&gt;p_flags &amp; PF_R) elf_prot |= PROT_READ;</span><br><span class="line"><span class="keyword">if</span> (elf_ppnt-&gt;p_flags &amp; PF_W) elf_prot |= PROT_WRITE;</span><br><span class="line"><span class="keyword">if</span> (elf_ppnt-&gt;p_flags &amp; PF_X) elf_prot |= PROT_EXEC;</span><br><span class="line"></span><br><span class="line">vaddr = elf_ppnt-&gt;p_vaddr;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//设置e_flags标志</span></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      total_size = <span class="built_in">total_mapping_size</span>(elf_phdata, loc-&gt;elf_ex.e_phnum);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//通过elf_map()来将用户虚拟地址load + vaddr和文件映像中的区域映射</span></span><br><span class="line"><span class="built_in">elf_map</span>(bprm-&gt;file, load_bias + vaddr, elf_ppnt, elf_prot, elf_flags, total_size);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>遍历所有段，如果该段是可加载段（child程序的可加载段就是代码段和数据段），就确定装入内存的地址load_bias + vaddr，并通过elf_map()来建立用户虚拟地址和文件映像中的区域映射。这里的load_bias是随机生成的偏移量，在映射到进程的虚拟地址空间时，栈、堆、解析器段的起始地址往往加上一个随机偏移量。因为整个程序的虚拟起始地址固定为0x08048000，敏感的栈区域容易被算出地址，被黑客利用。elf_map利用vm_map来建立虚拟地址到文件映像的映射，与mmap类似。<br>mmap会将文件从交换空间加载进内存，并为进程新创建一个vm_area_struct，同时建立vm_area_struct与进程段的映射关系，例如代码段的vm_area_struct的vm_start字段表明代码起始地址为0x08048000，vm_end字段表明代码段的结束位置。现在代码段和数据段已经加载到内存中了。并且代码段和数据段的vm_area_struct也已经设置好了，插入了进程的mmap链表中：</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBa5e38da11d4ff698e0aa0010fc73d156?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> </p></li><li><p>6、接下来是填写程序的入口地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (elf_interpreter) </span><br><span class="line"> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> interp_map_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">elf_entry = <span class="built_in">load_elf_interp</span>(&amp;loc-&gt;interp_elf_ex, interpreter, </span><br><span class="line">               &amp;interp_map_addr, load_bias, interp_elf_phdata);</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> &#123;</span><br><span class="line">elf_entry = loc-&gt;elf_ex.e_entry;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果存在解释器段，就通过load_elf_interp()将其映像装入内存, 并把将来进入用户空间的入口地址elf_entry设置成解释器映像的入口地址，这样返回用户空间时先执行解析器程序，将需要的共享库(shared lib)映射到进程的虚拟地址空间中。如果没有解释器段，也就是child程序的情况，那么直接从ELF Header的e_entry字段获得程序入口地址（child文件映像的入口地址）。<br>此时入口地址应该是0x08048d0a!</p></li><li>7、执行前的准备<br>首先调用create_elf_tables()函数填写目标文件的命令行参数、环境变量等信息。这些信息需要复制到用户空间，使它们在PC跳转到解释器或目标映像的程序入口地址时出现在用户空间堆栈上。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">create_elf_tables</span>(bprm, &amp;loc-&gt;elf_ex, load_addr, interp_load_addr);</span><br></pre></td></tr></table></figure>vm_area_struct线性区结构体的映射由mmap完成，现在完成mm_struct的初始化。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> current-&gt;mm-&gt;end_code = end_code;</span><br><span class="line"> current-&gt;mm-&gt;start_code = start_code;</span><br><span class="line"> current-&gt;mm-&gt;start_data = start_data;</span><br><span class="line"> current-&gt;mm-&gt;end_data = end_data;</span><br><span class="line"> current-&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br><span class="line"> <span class="keyword">if</span> ((current-&gt;flags &amp; PF_RANDOMIZE) &amp;&amp; (randomize_va_space &gt; <span class="number">1</span>)) </span><br><span class="line"> &#123;</span><br><span class="line">current-&gt;mm-&gt;brk = current-&gt;mm-&gt;start_brk = <span class="built_in">arch_randomize_brk</span>(current-&gt;mm);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>8、调用start_thread()函数准备执行此ELF程序<br>该函数是一个与体系结构相关的函数，在i386中其核心函数如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">regs-&gt;fs = <span class="number">0</span>;</span><br><span class="line">regs-&gt;ds = __USER_DS;</span><br><span class="line">regs-&gt;es = __USER_DS;</span><br><span class="line">regs-&gt;ss = __USER_DS;</span><br><span class="line">regs-&gt;cs = __USER_CS;</span><br><span class="line">regs-&gt;ip = new_ip;</span><br><span class="line">regs-&gt;sp = new_sp;</span><br><span class="line">regs-&gt;flags = X86_EFLAGS_IF;</span><br></pre></td></tr></table></figure>最后，函数跳转到regs-&gt;ip处(地址0x8048d0a)执行，execve系统调用结束。</li></ul><p>最终内存的情况如下图所示：</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBaa532b54422051cd4217f2017b02d9ec?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="70%" height="70%"/> </p><p>至此，程序的创建和可执行文件的加载过程全部结束！</p>]]></content>
    
    
    <summary type="html">本篇为小王同学的第3篇操作系统知识：Linux程序执行过程（ELF文件格式）以及进程创建(fork与execve系统调用)</summary>
    
    
    
    <category term="计算机基础知识" scheme="http://chudod.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="操作系统" scheme="http://chudod.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://chudod.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>使用触发操作卸载集合通信</title>
    <link href="http://chudod.github.io/2022/04/28/Triggered_Operation/"/>
    <id>http://chudod.github.io/2022/04/28/Triggered_Operation/</id>
    <published>2022-04-27T16:00:00.000Z</published>
    <updated>2022-04-28T09:25:57.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>天河的互连网络接口中设计了一种基于触发的通信卸载机制，集合通信操作卸载到互连网络中自主触发执行。互连网络中设计的计算逻辑部件，可以支持归约操作中的各种计算操作，从而将集合通信操作完全卸载(offload)到网络中。事实上，基于触发操作(Triggered Operation)的通信卸载机制还有可编程网络接口$\verb+API-Protals 4.0+$，富士通推出的片上互连系统$\verb+Tofu-2+$（结点之间采用控制报文触发进行集合通信操作的卸载，与天河互连网络通信卸载实现机制很相似），以及$\verb+Myrinet+$等等（补充中）。通过$\verb+Google+$上论文的引用关系，我发现最早提出触发机制的是$\verb+Portals 4+$，于2010年提出，寻根之旅了属于是。</p><h1 id="寻根之旅：Protals-4"><a href="#寻根之旅：Protals-4" class="headerlink" title="寻根之旅：Protals 4"></a>寻根之旅：Protals 4</h1><p>最早利用触发机制实现集合通信卸载的工作是$\verb+Portals 4+$上为$\verb+MPI_Allreduce+$操作设计的，于2010年发表在<a href="https://ieeexplore.ieee.org/abstract/document/6041532">Enabling Flexible Collective Communication Offload with Triggered Operations</a>上:”This paper presents triggered operations — a semantic building block that allows the key components of collective communications to be offloaded while allowing the host side software to define the algorithm”。$\verb+Portals 4+$设计了一个语义模块，包含触发操作(Trigger Operation)和计数事件机制(Counting events)。当计数事件到达了一个特定的阈值时，应用程序就会调度一个指定的网络操作。并且利用$\verb+Portals 4+$定义的触发函数重新实现了$\verb+Tree Algorithm+$和$\verb+Recursive Doubling+$。随后$\verb+Portals 4+$又为$\verb+Barrier+$和$\verb+Broadcast+$设计了触发操作算法（<a href="https://link.springer.com/chapter/10.1007/978-3-642-15646-5_26">原文链接</a>）。触发操作在语义上功能强大，并且能够提高性能。</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBca6784a6d45e7df074c9c9aa2673e557?method=download&shareKey=6655e070e6950d853516df65854d5ecf" width="70%" height="70%"/>  </p><h1 id="片上互连系统：Tofu-2"><a href="#片上互连系统：Tofu-2" class="headerlink" title="片上互连系统：Tofu-2"></a>片上互连系统：Tofu-2</h1>]]></content>
    
    
    <summary type="html">理解和追根溯源“利用触发机制实现的集合通信卸载”。</summary>
    
    
    
    <category term="并行计算" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="In-Network Collectives" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/In-Network-Collectives/"/>
    
    
    <category term="并行计算" scheme="http://chudod.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="集合通信" scheme="http://chudod.github.io/tags/%E9%9B%86%E5%90%88%E9%80%9A%E4%BF%A1/"/>
    
    <category term="高性能计算" scheme="http://chudod.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>高性能互连网络与拓扑感知算法</title>
    <link href="http://chudod.github.io/2022/04/25/Topology_Aware_Collectives/"/>
    <id>http://chudod.github.io/2022/04/25/Topology_Aware_Collectives/</id>
    <published>2022-04-24T16:00:00.000Z</published>
    <updated>2022-04-28T03:22:49.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>拓扑感知(Topology-Aware)的集合通信算法是近些年兴起的一个研究方向，顾名思义，就是将MPI的集合通信算法部署到高性能计算网络上，来充分发挥网络的性能，并且针对不同网络的拓扑结构和协议特点来设计不同的集合通信算法。这一页面列举了最近时髦的一些HPC网络以及对应的拓扑感知算法。在Top 500排行榜中的计算机系统通常采用的网络拓扑结构有Fattree、Torus、Dragonfly，目前，前几名没有用到Dragonfly。</p><h1 id="Gragonfly网络"><a href="#Gragonfly网络" class="headerlink" title="Gragonfly网络"></a>Gragonfly网络</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Gragonfly（蜻蜓）网络是最近非常时髦的一种HPC网络，在2008年提出：<a href="https://dl-acm-org-s.nudtproxy.yitlink.com/doi/10.1145/1394608.1382129">Technology-Driven, Highly-Scalable Dragonfly Topology</a>。其优点是高度的可伸缩性(high scalability)，低网络直径(low diameter)、成本低(low cost)等等。目前许多HPC系统都使用了Dragonfly网络拓扑。<br>下图是一个9组路由器72个终端节点的Dragonfly网络的例子（图片来源:<a href="https://ieeexplore-ieee-org-s.nudtproxy.yitlink.com/document/9644896">文献链接</a>）。</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBc0e3f19d5bb9c51887b22cf2f8c218ba?method=download&shareKey=4561f9353c0edc6f6b5daa810174cdbe" width="40%" height="40%"/>   </p><p>Dragonfly网络分成Group层、System层这两层：</p><ul><li>Group层：一个Group内一共$a$个交换机（或路由器），$a$个交换机都是全连接的，一个交换机连接着$p$个计算节点，上图中一个路由器连接两个计算节点。上图中的$9$个虚线框代表着$9$个Group层，每个Group层有$4$个全连接的路由器。</li><li>System层：一共有$g$个Group，每个Group视为一个虚拟的交换机，Group之间进行全连接，在图中就是$9$个Group进行全连接。组内的每个交换机与其他交换机的连接中，有$a-1$条链路连接到组内的交换机，还有$h=\frac{g-1}{a}$条链路是与其他Group之中的交换机相连结。在上图中，每个路由器有$3$条线连接到组内的路由器，还有$2$条连接到了其他Group中的路由器。并且组内的链路(intra-group)的延迟比组间链路(inter-group)的延迟高不少。  </li></ul><h2 id="网络属性与形式化表达"><a href="#网络属性与形式化表达" class="headerlink" title="网络属性与形式化表达"></a>网络属性与形式化表达</h2><p>Gragonfly网络可以用$DF(p,a,h,g)$来形式化表达，例如上图中的例子可以用$DF(p=2,a=4,h=2,g=9)$来表达。一个Gragonfly网络最佳的参数配置是：</p><script type="math/tex; mode=display">a=2p=2h</script><p>因此可以得到如下的性质：</p><ul><li>每个交换机端口的数量为$p+h+(a-1)$</li><li>每个虚拟交换机（一个$Group$）中的外接端口数量为$ah$，整个网络的全局链路数为$\frac{a\cdot{h}\cdot{g}}{2}$</li><li>$Group$的数量为$g=ah+1$（由前面的公式$h=\frac{g-1}{a}$推导可得）</li><li>$DF(p,a,h,g)$网络中一共有$P=p\cdot{a}\cdot{g}=ap(ah+1)$个节点，因此$DF(n,2n,n,g)$这种最佳配置的网络中的计算节点的数量为$P=2p^2(2p^2+1)$</li></ul><h2 id="Dragonfly网络的拓扑感知集合通信算法"><a href="#Dragonfly网络的拓扑感知集合通信算法" class="headerlink" title="Dragonfly网络的拓扑感知集合通信算法"></a>Dragonfly网络的拓扑感知集合通信算法</h2><p>Dragonfly网络上做集合通信算法的工作不多，论文只有寥寥几篇。最早的论文发表在$\verb+2012 EuroMPI+$上。这几篇论文设计的集合通信算法中，唯独没有$Allreduce$操作，所以我的师兄才抓住了这个点，在Dragonfly网络上设计$\verb+Allreduce+$算法，发了一篇$\verb+ISPA+$的会议论文，在我看来是非常好的想法了。</p><h3 id="Collectives-on-Two-Tier-Direct-Networks"><a href="#Collectives-on-Two-Tier-Direct-Networks" class="headerlink" title="Collectives on Two-Tier Direct Networks"></a><a href="https://link.springer.com/chapter/10.1007/978-3-642-33518-1_12">Collectives on Two-Tier Direct Networks</a></h3><p>该工作在Dragonfly以及IBM PERCS这两个双层的网络上对常规的集合通信操作（包括$\verb+Scatter Gather Allgather Broadcast Reduce-Scatter Reduce+$这6中操作）针对网络拓扑的特点设计了拓扑感知算法。其思想主要是利用了局部链路(Local Link)比全局链路(Global Link)快很多得特点，而且算法设计得比较简单，优化空间很多。</p><h1 id="Bcube网络"><a href="#Bcube网络" class="headerlink" title="Bcube网络"></a>Bcube网络</h1><p>Bcube网络拓扑的结构如下所示：</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB5d657aab3c672d03c9ff7dc7b7ac1527?method=download&shareKey=4561f9353c0edc6f6b5daa810174cdbe" width="60%" height="60%"/>   </p><p>用$Bcube(n,k)$来形式化的表达$Bcube$网络，$n$表示网络中的每个交换机都有$n$个端口，连接到$n$个不同的主机（$n$一般取$2~32$），$k$表示每个主机都有$k$个网卡来连接到$k$个不同的交换机（$k$一般取$2~4$）。交换机一共有$k$层，所以每个主机的$k$个网卡分别连接到$0, 1, …, k-1$层的交换机。并且主机和主机之间没有直接的链路连接，必须通过交换机连接。下图所表示的就是一个$Bcube(3,2)$的网络（图片来源：<a href="https://proceedings.neurips.cc/paper/2018/file/f410588e48dc83f2822a880a68f78923-Paper.pdf">BML</a>）。</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBedc750c2ece3d90077374a411436e990?method=download&shareKey=4561f9353c0edc6f6b5daa810174cdbe" width="60%" height="60%"/>   </p><p>目前，在Bcube上做集合通信算法设计和优化的工作很少，即便有少数几篇相关的，也是在Bcube上做分布式机器学习参数同步算法的研究。由于参数同步操作与$\verb+Allreduce+$操作高度相似，因此在Bcube上设计参数同步算法也就相当于做$\verb+Allreduce+$算法。<br><a href="https://proceedings.neurips.cc/paper/2018/file/f410588e48dc83f2822a880a68f78923-Paper.pdf">BML:A High-performance, Low-cost Gradient Synchronization Algorithm for DML Training</a>是第一个在Bcube上做分布式机器学习参数同步算法的工作，其实该参数同步算法并不复杂，本质上就是一个$\verb+Reduce+$ + $\verb+Broadcast+$的组合，如下图所示:</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB7e70f458806199ea4992bf8eb594660b?method=download&shareKey=4561f9353c0edc6f6b5daa810174cdbe" width="60%" height="60%"/>  </p><h1 id="Torus网络"><a href="#Torus网络" class="headerlink" title="Torus网络"></a>Torus网络</h1><p>Torus的英文直译就是环面的意思，在每一维都将该维度坐标相同的计算节点组织成一个绕接的环，图中展示的是一个二维的Torus网络。</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBbaccac337aea7e37f3f4df12205d3db2?method=download&shareKey=4561f9353c0edc6f6b5daa810174cdbe" width="30%" height="30%"/> </p><h1 id="Dcell网络"><a href="#Dcell网络" class="headerlink" title="Dcell网络"></a>Dcell网络</h1><p>Dceil的拓扑结构看起来和Dragonfly网络非常相似。</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB4a9b8282c017c3476aa98370093376a7?method=download&shareKey=4561f9353c0edc6f6b5daa810174cdbe" width="40%" height="40%"/> </p>]]></content>
    
    
    <summary type="html">This page is for Topologies for HPC Networks and Topology-Aware collective communication algorithms.</summary>
    
    
    
    <category term="并行计算" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="Topology-Aware Algorithms" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/Topology-Aware-Algorithms/"/>
    
    
    <category term="并行计算" scheme="http://chudod.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="集合通信" scheme="http://chudod.github.io/tags/%E9%9B%86%E5%90%88%E9%80%9A%E4%BF%A1/"/>
    
    <category term="高性能计算" scheme="http://chudod.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
    <category term="Topology-Aware" scheme="http://chudod.github.io/tags/Topology-Aware/"/>
    
  </entry>
  
  <entry>
    <title>硬核狠人之Torsten Heofler</title>
    <link href="http://chudod.github.io/2022/04/20/TorstenHeofler/"/>
    <id>http://chudod.github.io/2022/04/20/TorstenHeofler/</id>
    <published>2022-04-19T16:00:00.000Z</published>
    <updated>2022-04-20T08:55:19.192Z</updated>
    
    
    <summary type="html">本篇为小王同学的第1篇硬核狠人系列：Torsten Heofler</summary>
    
    
    
    <category term="硬核狠人" scheme="http://chudod.github.io/categories/%E7%A1%AC%E6%A0%B8%E7%8B%A0%E4%BA%BA/"/>
    
    
    <category term="硬核狠人" scheme="http://chudod.github.io/tags/%E7%A1%AC%E6%A0%B8%E7%8B%A0%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>操作系统内存管理</title>
    <link href="http://chudod.github.io/2022/04/14/OS_Memory_Management/"/>
    <id>http://chudod.github.io/2022/04/14/OS_Memory_Management/</id>
    <published>2022-04-13T16:00:00.000Z</published>
    <updated>2022-04-20T08:46:35.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、分页系统"><a href="#一、分页系统" class="headerlink" title="一、分页系统"></a>一、分页系统</h1><h2 id="1、段页式系统"><a href="#1、段页式系统" class="headerlink" title="1、段页式系统"></a>1、段页式系统</h2><p>段页式内存管理的模型中，逻辑地址（虚拟地址）先根据分段系统转换成线性地址，然后线性地址在分页系统中查询，Linux中弱化了分段机制，只在80x86处理器中使用分段。$Linux$采用了4级分页模型来适应多种硬件环境，但在80x86处理器中（IA-32架构）中使用二级分页模型，即页目录表和页表结合，将第2、3级页表整合进了页全局目录中。在64位体系结构中，2级页表不再适用，因此IA-64体系结构采用了3级页表，64位地址中39位（9+9+9+12）来寻址。</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB0d12a226c3f38c1f969af829e12275af?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="60%" height="60%"/>  </p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB93d72c4515da95343499f2207f959eb8?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="60%" height="60%"/>  </p><h2 id="2、自己做的页目录表和页表"><a href="#2、自己做的页目录表和页表" class="headerlink" title="2、自己做的页目录表和页表"></a>2、自己做的页目录表和页表</h2><p>这是我本科做实验时自己做的页目录和页表。其中用户程序使用$\verb+0x00~0xcfffffff+$这3GB逻辑地址空间，系统程序使用$\verb+0xc0000000~0xffffffff+$这1GB逻辑地址空间。在物理内存中，$\verb+0x00~0xfffff+$这1MB空间留给BIOS、MBR、Loader、中断向量表，页目录表位于内存$\verb+0x100000~0x100fff+$，大小共1KB，含1024个页目录项。页表紧跟着页目录表后面，页表0的地址为$\verb+0x101000~0x101fff+$，页表1的地址为$\verb+0x102000~0x102fff+$，依次类推。<br>页目录表中的第$\verb+0~767+$页目录项映射到低3GB逻辑内存中，而第$\verb+768~1022+$页目录项映射到高1GB逻辑内存中，1023号页目录项指向页目录表自己，而768号页目录项指向页表0，769号页目录项指向页表1，以此类推。页表0的第一个页表项指向地址$\verb+0x00+$为起始的4KB物理页（最上面的物理页0）。</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBaa4e07bd5ea8a36a7fee1b719e45e1e8?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="60%" height="60%"/></p><p>注意所有用户的页目录表的$\verb+768~1022+$项完全相同，因为都指向共享的内核空间。创建进程时从页目录表的第$\verb+768~1022+$拷贝即可（图片中写错字了，应该是页目录表而不是页表）。</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBeef4de30e9a491b8e5e67f7ac6a28611?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="60%" height="60%"/></p><h1 id="二、Linux内存管理"><a href="#二、Linux内存管理" class="headerlink" title="二、Linux内存管理"></a>二、Linux内存管理</h1><p>这里以一个用户程序$\verb+abc.c+$为例来探究Linux系统的内存管理策略。程序如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> bar[<span class="number">3968</span>]=<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> foo[<span class="number">4096</span>]=<span class="string">&quot;this is not a test\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">output_loop</span><span class="params">(<span class="type">char</span> * str)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">    write(<span class="number">2</span>, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    sched_yield();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> pid1, pid2, status;</span><br><span class="line"></span><br><span class="line">  write(<span class="number">2</span>, foo, <span class="built_in">strlen</span>(foo));</span><br><span class="line">  <span class="built_in">strcpy</span>(foo, <span class="string">&quot;you are modified\n&quot;</span>);</span><br><span class="line">  write(<span class="number">2</span>, foo, <span class="built_in">strlen</span>(foo));</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (!(pid1 = fork()))&#123;</span><br><span class="line">    output_loop(<span class="string">&quot;B  &quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(pid2 = fork()))&#123;</span><br><span class="line">    output_loop(<span class="string">&quot;C  &quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output_loop(<span class="string">&quot;A  &quot;</span>);</span><br><span class="line">  waitpid(pid1, &amp;status, <span class="number">0</span>);</span><br><span class="line">  waitpid(pid2, &amp;status, <span class="number">0</span>);</span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="1、进程地址空间"><a href="#1、进程地址空间" class="headerlink" title="1、进程地址空间"></a>1、进程地址空间</h2><p>abc程序的逻辑地址空间（右侧）如下图所示。其中用户程序使用$\verb+0x00-0xcfffffff+$这3GB逻辑地址空间，$\verb+abc+$程序的代码段为$\verb+0x08048000-0x080e8fff+$这161个页面，代码段为$\verb+0x080e9000-0x080ecfff+$这4个页面。数据段只包含$bar$和$foo$这两个变量对应的字符串，$bar$的地址为$\verb+0x080e9000+$，虽然只有3968个字节，但是也分配了2个页面（4096个字节），占用数据段中的第0、1个页面，$foo$的地址为$\verb+0x080eb000+$，占用数据段中的第2、3个页面。$\verb+task_struct+$为Linux的进程控制块PCB，里面包含指向内存控制块$\verb+mm_struct+$（所有内核进程的$\verb+mm_struct+$全部内容均为0）的指针。$\verb+mm_struct+$包含指向页目录表的指针$\verb+pgd+$以及指向$\verb+vm_area_struct+$线性区结构的指针$\verb+mmap+$，结构体$\verb+vm_area_struct+$描述的对应逻辑段的起始和结束逻辑地址等信息。所有$\verb+vm_area_struct+$组织成一棵红黑树。<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB4e818deadc690a92531ae4b7dd59f4f9?method=download&amp;shareKey=69113f8f61e335d1864757cf6d288929" alt="Linux分页系统以及abc程序的地址空间"><br>$foo$字符串的逻辑地址为$\verb+0x080eb000+$，高10位$\verb+0x20+$表示从页目录表的第$\verb+0x20+$项（对应的偏移为$\verb+0x80+$，一个页表项4个字节）取出页表地址，注意该处的$\verb+0x07518067+$的低12位为标志，不表示地址，页表的单位为4KB，故页表地址的低12位总是0。然后从$foo$字符串的中间10位$\verb+0xeb+$对应的偏移$\verb+0x3ac+$从页表中取出页帧的起始地址$\verb+0x065c6000+$，最后与$foo$字符串低12位页内偏移$\verb+0x000+$直接相加就可以得到$foo$字符串的物理地址。</p><h2 id="2、Linux的页描述符和页高速缓存"><a href="#2、Linux的页描述符和页高速缓存" class="headerlink" title="2、Linux的页描述符和页高速缓存"></a>2、Linux的页描述符和页高速缓存</h2><p>内存中的一个页称为页帧($page\ frame$)，一个页帧对应一个32字节的页描述符$\verb+struct page+$来描述，页帧描述符数组$\verb+struct page mem_map[]+$来描述所有的页帧，占整个内存空间的$\frac{32}{4096}=\frac{1}{128}$。<br>为了更快速的读取文件，Linux在$\verb+abc+$程序刚开始运行时，数据段还没有被访问前就已经把文件中的数据段缓存入了内存中，但是页目录表和页表并没有内容指向这部分缓存，Linux只会在访问数据段中的变量时才会分配页目录项和页表项（这也叫做“请求调页”），缓存的页框称为页高速缓存。页高速缓存的每一个页框对应一个页描述符，页描述符用基树组织起来，如下图所示。</p><p><div style="align: center"><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB2ba0e77ad04bc1d9cac6fbc86f2116b9?method=download&shareKey=69113f8f61e335d1864757cf6d288929" width="60%" height="60%"/></p><p>本例中$\verb+abc+$程序的基树如下图所示：<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB16b4d85145c8837036c4a41d3cfcc745?method=download&amp;shareKey=69113f8f61e335d1864757cf6d288929" alt=""><br>图中数据段的页描述符的偏移为$\verb+0xa0+$，应该位于第2个基树叶子节点的第32个槽，该槽中的指针指向对应的$\verb+struct page+$，再指向对应的页帧缓存。  </p><h1 id="三、Linux缺页处理"><a href="#三、Linux缺页处理" class="headerlink" title="三、Linux缺页处理"></a>三、Linux缺页处理</h1><h2 id="1、缺页处理流程"><a href="#1、缺页处理流程" class="headerlink" title="1、缺页处理流程"></a>1、缺页处理流程</h2><p>这里以$\verb+abc+$程序中的三个函数来分析缺页处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">write(<span class="number">2</span>, foo, <span class="built_in">strlen</span>(foo));</span><br><span class="line"><span class="built_in">strcpy</span>(foo, <span class="string">&quot;you are modified\n&quot;</span>);</span><br><span class="line">write(<span class="number">2</span>, foo, <span class="built_in">strlen</span>(foo));</span><br></pre></td></tr></table></figure></p><h3 id="执行第一个write系统调用"><a href="#执行第一个write系统调用" class="headerlink" title="执行第一个write系统调用"></a>执行第一个write系统调用</h3><p>数据段包含$\verb+bar+$和$\verb+foo+$字符串，$\verb+foo+$字符串的起始地址为$\verb+0x080eb000+$，占2个页帧。程序执行到$\verb+write+$函数前一刻，数据段作为页高速缓存，缓存在了内存中，但是页目录项和页表项均为0，没有指向这个页缓存。程序在内核态往虚拟地址0x080ecf20(数据段第4页)写内容，（我也不知道写的是什么内容，可能是初始化的信息），发现页目录项为0。<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB71a5c80affeec83e41ff2c5e05c29bbd?method=download&amp;shareKey=69113f8f61e335d1864757cf6d288929" alt="第一次缺页时的初始状态"><br>此时引发缺页异常，执行$\verb+__do_page_fault+$缺页处理函数，执行$\verb+do_cow_fault+$写时复制，修改页目录项，但页表项仍然全0，再从$\verb+0x065c9000+$拷贝数据到另一片内存$\verb+0x01b35000+$中，并修改第4个页表项为$\verb+0x01b35067+$(最低位为7表示该页面可写)，指向拷贝的内存。最后回到引发缺页的指令，重启该指令往逻辑地址$\verb+0x080e9fc4+$（也就是物理地址$\verb+0x01b35000+$处）写内容。<br>注意，页表项不能直接指向页缓存$\verb+0x065d1000+$处并向该地址写内容，必须先拷贝内容到另一块内存中，否则页缓存$\verb+0x065d1000+$成为脏页面，脏页面的内容会写回磁盘中，从而引起磁盘上程序内容的改变。<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBc26ad4fdc414d7430d64c730752ee683?method=download&amp;shareKey=69113f8f61e335d1864757cf6d288929" alt="第一次缺页处理"><br>然后程序在用户态往$\verb+0x080e9fc4+$(数据段第1页)写内容，发现页帧不存在，开始缺页处理，执行$\verb+do_cow_fault+$函数，从$\verb+0x065c6000+$拷贝数据到另一片内存中$\verb+0x01b34000+$，并修改第一个页表项指向拷贝的内存。<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB66fe4e1cdb31a275d66e865d022732bf?method=download&amp;shareKey=69113f8f61e335d1864757cf6d288929" alt="第二次缺页处理"><br>随后是第3次缺页异常，在用户态往$\verb+0x80ea040+$(数据段第2页)读内容，发现页帧不存在，引发缺页处理，执行$\verb+do_read_fault+$函数，因为只是读该页面，不需要写页面，所以修改第2、3个页表项指向第2、3个页帧缓存$\verb+0x065cf000+$和$\verb+0x065d0000+$即可，页表项的最低4位为5表示该页面只读。<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB8faa3a5ed4916f2e7e69871238033cff?method=download&amp;shareKey=69113f8f61e335d1864757cf6d288929" alt=""><br>之后是第4次缺页异常，程序在用户态往$\verb+0x80ea040+$(数据段第2页)写内容，发现该页面只读，执行$\verb+do_wp_page+$函数，从第2个页表项指向的$\verb+0x065cf000+$拷贝内容到新的内存地址$\verb+0x07d85000+$并修改页表项指向拷贝的新页帧。我发现程序往这个地址写的竟然是空字符串””。<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB5c7b6dc7cb9a07568443d4d5a5bb82a9?method=download&amp;shareKey=69113f8f61e335d1864757cf6d288929" alt=""><br>此时程序刚刚进入$main$函数，然后终端打印$\verb+foo+$字符串，$\verb+write+$结束。全局的视角看起来应该是这样：<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB26fa4947c1e7e03f31b54dddae8be1a9?method=download&amp;shareKey=69113f8f61e335d1864757cf6d288929" alt=""></p><h3 id="执行strcpy函数"><a href="#执行strcpy函数" class="headerlink" title="执行strcpy函数"></a>执行strcpy函数</h3><p>$\verb+strcpy+$函数将$\verb+foo+$字符串的内容改写成”you are modified.”。此时$\verb+foo+$字符串所在的地址为第3个页表项指向的页面缓存。在用户态往$\verb+0x80eb000+$(第3页，即foo字符串地址)写内容，发现该页面只读，执行$\verb+do_wp_page+$函数，从第3个页表项指向的$\verb+foo+$字符串地址$\verb+0x065d0000+$拷贝字符串到内存$0x01b3a000$处并修改页表项指向新拷贝的内存地址，再往新的页帧写字符串$\verb+”you are modified”+$。<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB3f2c9510c2c066da94bf25f657684598?method=download&amp;shareKey=69113f8f61e335d1864757cf6d288929" alt=""><br>$\verb+strcpy+$函数结束时4个页表项都将最低为从7改为5，此时页面只读，不可写，然后$\verb+strcpy+$结束，执行$\verb+write+$函数，打印新的字符串。<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBe288d6203e8207ba7782b958abb5ffbe?method=download&amp;shareKey=69113f8f61e335d1864757cf6d288929" alt=""></p><h2 id="2、回写脏页面"><a href="#2、回写脏页面" class="headerlink" title="2、回写脏页面"></a>2、回写脏页面</h2><p>若在执行$\verb+strcpy+$函数之前，把第3个页表项标志位改为7结尾，页面变为可写，在执行$\verb+strcpy+$函数时，新字符串的将会被写入第3个页表项指向的$\verb+foo+$字符串地址$\verb+0x065d0000+$中，该页帧成为脏页面，回写到磁盘上，磁盘上的程序内容也会被更改，下次执行abc程序时直接输出新字符串。<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBd1510963910d7d4323be7e44608a5c7b?method=download&amp;shareKey=69113f8f61e335d1864757cf6d288929" alt=""><br>下次执行程序时的结果：<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB3a05bb03ae842bdefed44e3e9abd9af8?method=download&amp;shareKey=69113f8f61e335d1864757cf6d288929" alt=""><br>两次打印的都是修改后的字符串。</p>]]></content>
    
    
    <summary type="html">本篇为小王同学的第2篇操作系统知识：OS内存管理</summary>
    
    
    
    <category term="计算机基础知识" scheme="http://chudod.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="操作系统" scheme="http://chudod.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://chudod.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MPI_Allreduce的在OpenMPI、MPICH中的实现</title>
    <link href="http://chudod.github.io/2022/04/13/OpenMPI&amp;MPICH_Allreduce/"/>
    <id>http://chudod.github.io/2022/04/13/OpenMPI&amp;MPICH_Allreduce/</id>
    <published>2022-04-12T16:00:00.000Z</published>
    <updated>2022-05-01T09:13:20.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Allreduce算法列表"><a href="#Allreduce算法列表" class="headerlink" title="Allreduce算法列表"></a>Allreduce算法列表</h1><h2 id="1、OpenMPI-4-1中的MPI-Allreduce算法"><a href="#1、OpenMPI-4-1中的MPI-Allreduce算法" class="headerlink" title="1、OpenMPI-4.1中的MPI_Allreduce算法"></a>1、OpenMPI-4.1中的MPI_Allreduce算法</h2><p>$\verb+OpenMPI-4.1.2+$是最新版本的$\verb+OpenMPI+$，算法的具体选择在$\verb+ompi/mca/coll/tuned/coll_tuned_decision_fixed.c+$和$\verb+ompi/mca/coll/tuned/coll_tuned_decision_dynamic.c+$文件里，用户可以指定规则以及选择使用的算法，并且$\verb+OpenMPI+$使用了6种算法，分别是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Algorithms:</span><br><span class="line">   &#123;<span class="number">1</span>, <span class="string">&quot;basic_linear&quot;</span>&#125;: Reduce + Broadcast</span><br><span class="line">   &#123;<span class="number">2</span>, <span class="string">&quot;nonoverlapping&quot;</span>&#125;: Reduce +Broadcast</span><br><span class="line">   &#123;<span class="number">3</span>, <span class="string">&quot;recursive_doubling&quot;</span>&#125;: Recursive Doubling</span><br><span class="line">   &#123;<span class="number">4</span>, <span class="string">&quot;ring&quot;</span>&#125;: <span class="built_in">Ring</span>(Segmented Messages) + <span class="built_in">Allgather</span>(Ring)</span><br><span class="line">   &#123;<span class="number">5</span>, <span class="string">&quot;segmented_ring&quot;</span>&#125;: Segmented Ring</span><br><span class="line">   &#123;<span class="number">6</span>, <span class="string">&quot;rabenseifner&quot;</span>&#125;: Reduce-Scatter + Allgather</span><br><span class="line">   <span class="comment">/* Currently, ring, segmented ring, and rabenseifner do not support non-commutative operations. */</span></span><br></pre></td></tr></table></figure><br>默认使用$\verb+/coll_tuned_decision_fixed.c+$里的规则，具体的选择方法如下(原代码是100多行的$else-if$，贼暴力)：<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBef75c5797a8fe9a7d3afe7d9f84db3a2?method=download&amp;shareKey=0412dcb1d5f95516723864a4f1a48a13" alt=""><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBe38b3f100dd6599ec413faa1ee25edcf?method=download&amp;shareKey=0412dcb1d5f95516723864a4f1a48a13" alt=""><br>除了默认的规则之外，用户还可以指定参数来选择对应的算法。  </p><h2 id="2、MPICH中的MPI-Allreduce算法"><a href="#2、MPICH中的MPI-Allreduce算法" class="headerlink" title="2、MPICH中的MPI_Allreduce算法"></a>2、MPICH中的MPI_Allreduce算法</h2><p>$\verb+MPICH-4.0.2+$是最新版本的$\verb+MPICH+$，在$\verb+MPICH+$中调用$\verb+MPIR_Csel_search+$函数来确定参数，$\verb+MPIR_Csel_search+$返回的值决定采用何种算法。算法的选择逻辑在$\verb+mpich-4.0.2/src/mpi/coll/mpir_coll.c+$的4496行的$\verb+MPIR_Allreduce_allcomm_auto+$函数处，$\verb+MPICH+$中的5种算法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Algorithms:</span><br><span class="line">    <span class="number">1</span>-&gt; <span class="string">&quot;MPIR_Allreduce_intra_smp&quot;</span>: Reduce + Broadcast;</span><br><span class="line">    <span class="number">2</span>-&gt; <span class="string">&quot;MPIR_Allreduce_intra_recursive_doubling&quot;</span>: Recursive Doubling;</span><br><span class="line">    <span class="number">3</span>-&gt; <span class="string">&quot;MPIR_Allreduce_intra_reduce_scatter_allgather&quot;</span>: Scatter + Allgather;</span><br><span class="line">    <span class="number">4</span>-&gt; <span class="string">&quot;MPIR_Allreduce_inter_reduce_exchange_bcast&quot;</span>: a variant of Reduce + Broadcast;</span><br><span class="line">    <span class="number">5</span>-&gt; <span class="string">&quot;MPIR_Allreduce_allcomm_nb&quot;</span>: Nonblocking algorithm, namely MPIR_Iallreduce;</span><br></pre></td></tr></table></figure></p><h1 id="Allreduce算法实现"><a href="#Allreduce算法实现" class="headerlink" title="Allreduce算法实现"></a>Allreduce算法实现</h1><h2 id="1、-Reduce-Broadcast-算法"><a href="#1、-Reduce-Broadcast-算法" class="headerlink" title="1、$Reduce$+$Broadcast$算法"></a>1、$Reduce$+$Broadcast$算法</h2><h3 id="OpenMPI版"><a href="#OpenMPI版" class="headerlink" title="OpenMPI版"></a>OpenMPI版</h3><h4 id="basic-linear函数"><a href="#basic-linear函数" class="headerlink" title="basic_linear函数"></a>basic_linear函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_base_allreduce_intra_basic_linear</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sbuf, <span class="type">void</span> *rbuf, <span class="type">int</span> count, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *dtype, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">struct</span> <span class="type">ompi_op_t</span> *op, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Reduce to 0 and broadcast. */</span></span><br><span class="line">    <span class="keyword">if</span> (MPI_IN_PLACE == sbuf) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == rank)  </span><br><span class="line">            err = <span class="built_in">ompi_coll_base_reduce_intra_basic_linear</span> (MPI_IN_PLACE, rbuf, count, dtype, op, <span class="number">0</span>, comm, <span class="keyword">module</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            err = <span class="built_in">ompi_coll_base_reduce_intra_basic_linear</span>(rbuf, <span class="literal">NULL</span>, ...);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        err = <span class="built_in">ompi_coll_base_reduce_intra_basic_linear</span>(sbuf, rbuf, ...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (MPI_SUCCESS != err) <span class="keyword">return</span> err;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ompi_coll_base_bcast_intra_basic_linear</span>(rbuf, count, dtype, <span class="number">0</span>, comm, <span class="keyword">module</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中$\verb+MPI_IN_PLACE+$参数用在$\verb+MPI_GATHER+$、$\verb+MPI_Reduce+$等有$\verb+send_buf+$和$\verb+recv_buf+$的函数中，用来代替$\verb+send_buf+$，说明当前进程既发送又接受数据，而且要发送的数据和在要接收的数据的保存在同一内存。</p><h4 id="nonoverlapping函数"><a href="#nonoverlapping函数" class="headerlink" title="nonoverlapping函数"></a>nonoverlapping函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_base_allreduce_intra_nonoverlapping</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sbuf, <span class="type">void</span> *rbuf, <span class="type">int</span> count, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *dtype, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">struct</span> <span class="type">ompi_op_t</span> *op, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个参数是sbuf 或者是 MPI_IN_PLACE</span></span><br><span class="line">    comm-&gt;c_coll-&gt;<span class="built_in">coll_reduce</span> (sbuf, rbuf, count, dtype, op, <span class="number">0</span>, comm, comm-&gt;c_coll-&gt;coll_reduce_module);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MPI_SUCCESS != err) <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> comm-&gt;c_coll-&gt;<span class="built_in">coll_bcast</span>(rbuf, count, dtype, <span class="number">0</span>, comm, comm-&gt;c_coll-&gt;coll_bcast_module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MPICH版"><a href="#MPICH版" class="headerlink" title="MPICH版"></a>MPICH版</h3><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h2 id="2、-Recursive-Doubling-算法"><a href="#2、-Recursive-Doubling-算法" class="headerlink" title="2、$Recursive$ $Doubling$算法"></a>2、$Recursive$ $Doubling$算法</h2><h3 id="OpenMPI版-1"><a href="#OpenMPI版-1" class="headerlink" title="OpenMPI版"></a>OpenMPI版</h3><h4 id="recursivedoubling函数"><a href="#recursivedoubling函数" class="headerlink" title="recursivedoubling函数"></a>recursivedoubling函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*         算法保持了规约操作的顺序，所以可支持满足以及不满足交换律的操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         Example on 7 nodes:</span></span><br><span class="line"><span class="comment"> *         Initial state</span></span><br><span class="line"><span class="comment"> *         #      0       1      2       3      4       5      6</span></span><br><span class="line"><span class="comment"> *               [0]     [1]    [2]     [3]    [4]     [5]    [6]</span></span><br><span class="line"><span class="comment"> *         Initial adjustment step for non-power of two nodes.</span></span><br><span class="line"><span class="comment"> *         old rank      1              3              5      6</span></span><br><span class="line"><span class="comment"> *         new rank      0              1              2      3</span></span><br><span class="line"><span class="comment"> *                     [0+1]          [2+3]          [4+5]   [6]</span></span><br><span class="line"><span class="comment"> *         Step 1</span></span><br><span class="line"><span class="comment"> *         old rank      1              3              5      6</span></span><br><span class="line"><span class="comment"> *         new rank      0              1              2      3</span></span><br><span class="line"><span class="comment"> *                     [0+1+]         [0+1+]         [4+5+]  [4+5+]</span></span><br><span class="line"><span class="comment"> *                     [2+3+]         [2+3+]         [6   ]  [6   ]</span></span><br><span class="line"><span class="comment"> *         Step 2</span></span><br><span class="line"><span class="comment"> *         old rank      1              3              5      6</span></span><br><span class="line"><span class="comment"> *         new rank      0              1              2      3</span></span><br><span class="line"><span class="comment"> *                     [0+1+]         [0+1+]         [0+1+]  [0+1+]</span></span><br><span class="line"><span class="comment"> *                     [2+3+]         [2+3+]         [2+3+]  [2+3+]</span></span><br><span class="line"><span class="comment"> *                     [4+5+]         [4+5+]         [4+5+]  [4+5+]</span></span><br><span class="line"><span class="comment"> *                     [6   ]         [6   ]         [6   ]  [6   ]</span></span><br><span class="line"><span class="comment"> *         Final adjustment step for non-power of two nodes</span></span><br><span class="line"><span class="comment"> *         #      0       1      2       3      4       5      6</span></span><br><span class="line"><span class="comment"> *              [0+1+] [0+1+] [0+1+]  [0+1+] [0+1+]  [0+1+] [0+1+]</span></span><br><span class="line"><span class="comment"> *              [2+3+] [2+3+] [2+3+]  [2+3+] [2+3+]  [2+3+] [2+3+]</span></span><br><span class="line"><span class="comment"> *              [4+5+] [4+5+] [4+5+]  [4+5+] [4+5+]  [4+5+] [4+5+]</span></span><br><span class="line"><span class="comment"> *              [6   ] [6   ] [6   ]  [6   ] [6   ]  [6   ] [6   ]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_base_allreduce_intra_recursivedoubling</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sbuf, <span class="type">void</span> *rbuf, <span class="type">int</span> count, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *dtype, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="keyword">struct</span> <span class="type">ompi_op_t</span> *op, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    <span class="type">int</span> rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (MPI_IN_PLACE != sbuf) <span class="comment">//copy data form sbuf to rbuf;</span></span><br><span class="line">        <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Determine nearest power of two less than or equal to size */</span></span><br><span class="line">    adjsize = <span class="built_in">opal_next_poweroftwo</span> (size);</span><br><span class="line">    adjsize &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle non-power-of-two case:</span></span><br><span class="line"><span class="comment">       - Even ranks less than 2 * extra_ranks send their data to (rank + 1), and sets new rank to -1.</span></span><br><span class="line"><span class="comment">       - Odd ranks less than 2 * extra_ranks receive data from (rank - 1), apply appropriate operation, and set new rank to rank/2</span></span><br><span class="line"><span class="comment">       - Everyone else sets rank to rank - extra_ranks</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    extra_ranks = size - adjsize;</span><br><span class="line">    <span class="keyword">if</span> (rank &lt;  (<span class="number">2</span> * extra_ranks)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == (rank % <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span>(tmpsend, count, dtype, (rank + <span class="number">1</span>), ..., comm));</span><br><span class="line">            newrank = <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>(tmprecv, count, dtype, (rank - <span class="number">1</span>), ..., comm, ...));</span><br><span class="line">            <span class="comment">/* tmpsend = tmprecv (op) tmpsend */</span></span><br><span class="line">            <span class="built_in">ompi_op_reduce</span>(op, tmprecv, tmpsend, count, dtype);</span><br><span class="line">            newrank = rank &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;newrank = rank - extra_ranks;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Communication/Computation loop</span></span><br><span class="line"><span class="comment">       - Exchange message with remote node.</span></span><br><span class="line"><span class="comment">       - Perform appropriate operation taking in account order of operations:</span></span><br><span class="line"><span class="comment">       result = value (op) result</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">for</span> (distance = <span class="number">0x1</span>; distance &lt; adjsize; distance &lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newrank &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* Determine remote node (异或操作)*/</span></span><br><span class="line">        newremote = newrank ^ distance;</span><br><span class="line">        remote = (newremote &lt; extra_ranks)? (newremote * <span class="number">2</span> + <span class="number">1</span>):(newremote + extra_ranks);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exchange the data */</span></span><br><span class="line">        ret = <span class="built_in">ompi_coll_base_sendrecv_actual</span>(tmpsend, count, dtype, remote, ..., tmprecv, count, dtype, remote, ..., comm, ...);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Apply operation */</span></span><br><span class="line">        <span class="keyword">if</span> (rank &lt; remote) &#123;</span><br><span class="line">            <span class="comment">/* tmprecv = tmpsend (op) tmprecv, ompi_op_reduce(op, soruce, target, ...)*/</span></span><br><span class="line">            <span class="built_in">ompi_op_reduce</span>(op, tmpsend, tmprecv, count, dtype);</span><br><span class="line">            tmpswap = tmprecv;</span><br><span class="line">            tmprecv = tmpsend;</span><br><span class="line">            tmpsend = tmpswap;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* tmpsend = tmprecv (op) tmpsend */</span></span><br><span class="line">            <span class="built_in">ompi_op_reduce</span>(op, tmprecv, tmpsend, count, dtype);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle non-power-of-two case:</span></span><br><span class="line"><span class="comment">       - Odd ranks less than 2 * extra_ranks send result from tmpsend to (rank - 1)</span></span><br><span class="line"><span class="comment">       - Even ranks less than 2 * extra_ranks receive result from (rank + 1)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (rank &lt; (<span class="number">2</span> * extra_ranks)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == (rank % <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>(rbuf, count, dtype, (rank + <span class="number">1</span>), ...));</span><br><span class="line">            tmpsend = (<span class="type">char</span>*)rbuf;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span>(tmpsend, count, dtype, (rank - <span class="number">1</span>), ...));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ensure that the final result is in rbuf */</span></span><br><span class="line">    <span class="keyword">if</span> (tmpsend != rbuf) <span class="comment">//copy form tmpsend to rbuf;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意新版$OpenMPI$中的$\verb+recursive doubling+$函数可以支持不满足交换律的操作，但是必须满足结合律。</p><h3 id="MPICH版-1"><a href="#MPICH版-1" class="headerlink" title="MPICH版"></a>MPICH版</h3><p>实现几乎完全一样，故略。</p><h2 id="4、reduce-scatter算法"><a href="#4、reduce-scatter算法" class="headerlink" title="4、reduce-scatter算法"></a>4、reduce-scatter算法</h2><h3 id="OpenMPI版-2"><a href="#OpenMPI版-2" class="headerlink" title="OpenMPI版"></a>OpenMPI版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * This algorithm is a combination of a reduce-scatter implemented with</span></span><br><span class="line"><span class="comment"> * recursive vector halving and recursive distance doubling, followed either</span></span><br><span class="line"><span class="comment"> * by an allgather implemented with recursive doubling.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Limitations:</span></span><br><span class="line"><span class="comment"> *   count &gt;= 2^&#123;\floor&#123;\log_2 p&#125;&#125;</span></span><br><span class="line"><span class="comment"> *   commutative operations only</span></span><br><span class="line"><span class="comment"> *   intra-communicators only</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_base_allreduce_intra_redscat_allgather</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sbuf, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *rbuf, <span class="type">int</span> count, <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *dtype,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> <span class="type">ompi_op_t</span> *op, <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> comm_size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    <span class="type">int</span> rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nsteps = <span class="built_in">opal_hibit</span>(comm_size, comm-&gt;c_cube_dim + <span class="number">1</span>);<span class="comment">/*ilog2(comm_size)*/</span></span><br><span class="line">    <span class="built_in">assert</span>(nsteps &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> nprocs_pof2 = <span class="number">1</span> &lt;&lt; nsteps;                   <span class="comment">/* flp2(comm_size) */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ptrdiff_t</span> lb, extent, dsize, gap = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ompi_datatype_get_extent</span>(dtype, &amp;lb, &amp;extent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &lt; nprocs_pof2 || !<span class="built_in">ompi_op_is_commute</span>(op)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ompi_coll_base_allreduce_intra_basic_linear</span>(sbuf, rbuf, count, dtype, op, comm, <span class="keyword">module</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sbuf != MPI_IN_PLACE) <span class="comment">//copy from sbuf to rbuf;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step 1. Reduce the number of processes to the nearest lower power of two</span></span><br><span class="line"><span class="comment">     * p&#x27; = 2^&#123;\floor&#123;\log_2 p&#125;&#125; by removing r = p - p&#x27; processes.</span></span><br><span class="line"><span class="comment">     * 1. All the even ranks send the second half of  the input vector to their right neighbor (rank + 1),</span></span><br><span class="line"><span class="comment">     *    and all the odd ranks send the first half of the input vector to their left neighbor (rank - 1).</span></span><br><span class="line"><span class="comment">     * 2. All 2r processes compute the reduction on their half.</span></span><br><span class="line"><span class="comment">     * 3. The odd ranks then send the result to their left neighbors (the even ranks).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> vrank, step, wsize;</span><br><span class="line">    <span class="type">int</span> nprocs_rem = comm_size - nprocs_pof2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank &lt; <span class="number">2</span> * nprocs_rem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> count_lhalf = count / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> count_rhalf = count - count_lhalf;</span><br><span class="line">        <span class="keyword">if</span> (rank % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Odd process -- exchange with (rank - 1)</span></span><br><span class="line"><span class="comment">             * Send the left half of the input vector to the left neighbor,</span></span><br><span class="line"><span class="comment">             * Recv the right half of the input vector from the left neighbor</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">ompi_coll_base_sendrecv</span>(rbuf, count_lhalf, dtype, rank - <span class="number">1</span>, ...,</span><br><span class="line">                            (<span class="type">char</span> *)tmp_buf + (<span class="type">ptrdiff_t</span>)count_lhalf * extent,</span><br><span class="line">                            count_rhalf, dtype, rank - <span class="number">1</span>, ..., rank);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Reduce on the right half of the buffers (result in rbuf) */</span></span><br><span class="line">            <span class="built_in">ompi_op_reduce</span>(op, (<span class="type">char</span> *)tmp_buf + (<span class="type">ptrdiff_t</span>)count_lhalf * extent,</span><br><span class="line">                        (<span class="type">char</span> *)rbuf + count_lhalf * extent, count_rhalf, dtype);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Send the right half to the left neighbor */</span></span><br><span class="line">            <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span>((<span class="type">char</span> *)rbuf + (<span class="type">ptrdiff_t</span>)count_lhalf * extent,</span><br><span class="line">                               count_rhalf, dtype, rank - <span class="number">1</span>, ..., comm));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* This process does not pariticipate in recursive doubling phase */</span></span><br><span class="line">            vrank = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Even process -- exchange with rank + 1</span></span><br><span class="line"><span class="comment">             * Send the right half of the input vector to the right neighbor,</span></span><br><span class="line"><span class="comment">             * Recv the left half of the input vector from the right neighbor</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">ompi_coll_base_sendrecv</span>((<span class="type">char</span> *)rbuf + (<span class="type">ptrdiff_t</span>)count_lhalf*extent,</span><br><span class="line">                            count_rhalf, dtype, rank + <span class="number">1</span>, ...,tmp_buf, </span><br><span class="line">                            count_lhalf, dtype, rank + <span class="number">1</span>, ..., comm, ..., rank);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Reduce on the left half of the buffers (result in rbuf) */</span></span><br><span class="line">            <span class="built_in">ompi_op_reduce</span>(op, tmp_buf, rbuf, count_lhalf, dtype);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Recv the right half from the right neighbor */</span></span><br><span class="line">            <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>((<span class="type">char</span> *)rbuf + (<span class="type">ptrdiff_t</span>)count_lhalf * extent,</span><br><span class="line">                            count_rhalf, dtype, rank + <span class="number">1</span>, ..., comm, ...));</span><br><span class="line"></span><br><span class="line">            vrank = rank / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; <span class="comment">/* rank &gt;= 2 * nprocs_rem */</span></span><br><span class="line">        vrank = rank - nprocs_rem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step 2. Reduce-scatter implemented with recursive vector halving and</span></span><br><span class="line"><span class="comment">     * recursive distance doubling. We have  new ranks and result in rbuf.</span></span><br><span class="line"><span class="comment">     *At the end, each process has 1 / p&#x27; of the total reduction result.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>* rindex = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(*rindex) * nsteps);</span><br><span class="line">    <span class="type">int</span>* sindex = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(*sindex) * nsteps);</span><br><span class="line">    <span class="type">int</span>* rcount = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(*rcount) * nsteps);</span><br><span class="line">    <span class="type">int</span>* scount = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(*scount) * nsteps);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vrank != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        step = <span class="number">0</span>;</span><br><span class="line">        wsize = count;</span><br><span class="line">        sindex[<span class="number">0</span>] = rindex[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">1</span>; mask &lt; nprocs_pof2; mask &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* On each iteration: rindex[step] = sindex[step] -- begining of the</span></span><br><span class="line"><span class="comment">            current window. Length of the current window is stored in wsize.*/</span></span><br><span class="line">            <span class="type">int</span> vdest = vrank ^ mask;</span><br><span class="line">            <span class="comment">/* Translate vdest virtual rank to real rank */</span></span><br><span class="line">            <span class="type">int</span> dest = (vdest &lt; nprocs_rem) ? vdest * <span class="number">2</span> : vdest + nprocs_rem;</span><br><span class="line">            <span class="keyword">if</span> (rank &lt; dest) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Recv into the left half of the current window, send the right</span></span><br><span class="line"><span class="comment">                 * half of the window to the peer (perform reduce on the left</span></span><br><span class="line"><span class="comment">                 * half of the current window)</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                rcount[step] = wsize / <span class="number">2</span>;</span><br><span class="line">                scount[step] = wsize - rcount[step];</span><br><span class="line">                sindex[step] = rindex[step] + rcount[step];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Recv into the right half of the current window, send the left</span></span><br><span class="line"><span class="comment">                 * half of the window to the peer (perform reduce on the right</span></span><br><span class="line"><span class="comment">                 * half of the current window)</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                scount[step] = wsize / <span class="number">2</span>;</span><br><span class="line">                rcount[step] = wsize - scount[step];</span><br><span class="line">                rindex[step] = sindex[step] + scount[step];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Send part of data from the rbuf, recv into the tmp_buf */</span></span><br><span class="line">            <span class="built_in">ompi_coll_base_sendrecv</span>((<span class="type">char</span> *)rbuf + (<span class="type">ptrdiff_t</span>)sindex[step] * extent,</span><br><span class="line">                            scount[step], dtype, dest, ...,</span><br><span class="line">                            (<span class="type">char</span> *)tmp_buf + (<span class="type">ptrdiff_t</span>)rindex[step] * extent, </span><br><span class="line">                            rcount[step], dtype, dest, ..., comm, ..., rank);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Local reduce: rbuf[] = tmp_buf[] &lt;op&gt; rbuf[] */</span></span><br><span class="line">            <span class="built_in">ompi_op_reduce</span>(op, (<span class="type">char</span>*)tmp_buf + (<span class="type">ptrdiff_t</span>)rindex[step] * extent,</span><br><span class="line">                           (<span class="type">char</span> *)rbuf + (<span class="type">ptrdiff_t</span>)rindex[step] * extent,</span><br><span class="line">                           rcount[step], dtype);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move the current window to the received message */</span></span><br><span class="line">            <span class="keyword">if</span> (step + <span class="number">1</span> &lt; nsteps) &#123;</span><br><span class="line">                rindex[step + <span class="number">1</span>] = rindex[step];</span><br><span class="line">                sindex[step + <span class="number">1</span>] = rindex[step];</span><br><span class="line">                wsize = rcount[step];</span><br><span class="line">                step++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Step 3. Allgather by the recursive doubling algorithm.</span></span><br><span class="line"><span class="comment">        * Each process has 1 / p&#x27; of the total reduction result:</span></span><br><span class="line"><span class="comment">        * rcount[nsteps - 1] elements in the rbuf[rindex[nsteps - 1], ...].</span></span><br><span class="line"><span class="comment">        * All exchanges are executed in reverse order relative to recursive doubling (previous step).</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        step = nsteps - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mask = nprocs_pof2 &gt;&gt; <span class="number">1</span>; mask &gt; <span class="number">0</span>; mask &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> vdest = vrank ^ mask;</span><br><span class="line">            <span class="comment">/* Translate vdest virtual rank to real rank */</span></span><br><span class="line">            <span class="type">int</span> dest = (vdest &lt; nprocs_rem) ? vdest * <span class="number">2</span> : vdest + nprocs_rem;</span><br><span class="line">            <span class="comment">/* Send rcount[step] elements from rbuf[rindex[step]...]</span></span><br><span class="line"><span class="comment">               Recv scount[step] elements to rbuf[sindex[step]...] */</span></span><br><span class="line">            <span class="built_in">ompi_coll_base_sendrecv</span>((<span class="type">char</span> *)rbuf + (<span class="type">ptrdiff_t</span>)rindex[step] * extent,</span><br><span class="line">                                rcount[step], dtype, dest, ...,</span><br><span class="line">                                (<span class="type">char</span> *)rbuf + (<span class="type">ptrdiff_t</span>)sindex[step] * extent,</span><br><span class="line">                                scount[step], dtype, dest, ..., comm, ..., rank);</span><br><span class="line">            step--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4. Send total result to excluded odd ranks. */</span></span><br><span class="line">    <span class="keyword">if</span> (rank &lt; <span class="number">2</span> * nprocs_rem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rank % <span class="number">2</span> != <span class="number">0</span>) <span class="comment">/* Odd process -- recv result from rank - 1 */</span></span><br><span class="line">            <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>(rbuf, count, dtype, rank - <span class="number">1</span>, ..., comm, ...));</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* Even process -- send result to rank + 1 */</span></span><br><span class="line">            <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span>(rbuf, count, dtype, rank + <span class="number">1</span>, ..., comm));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//free buffer rindex, sindex, rcount, scount;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、ring算法"><a href="#5、ring算法" class="headerlink" title="5、ring算法"></a>5、ring算法</h2><h3 id="OpenMPI版-3"><a href="#OpenMPI版-3" class="headerlink" title="OpenMPI版"></a>OpenMPI版</h3><p>注：只有在$OpenMPI$中才有$Ring$ $Allreduce$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 消息自动被分成M/N段，算法执行2*N - 1步。算法不能保证规约操作顺序，所以仅支持满足交换律的操作，并且消息量小于进程数时算法不能正常工作。</span></span><br><span class="line"><span class="comment"> * Example on 5 nodes:</span></span><br><span class="line"><span class="comment"> *         Initial state</span></span><br><span class="line"><span class="comment"> *   #      0              1             2              3             4</span></span><br><span class="line"><span class="comment"> *        [00]           [10]          [20]           [30]           [40]</span></span><br><span class="line"><span class="comment"> *        [01]           [11]          [21]           [31]           [41]</span></span><br><span class="line"><span class="comment"> *        [02]           [12]          [22]           [32]           [42]</span></span><br><span class="line"><span class="comment"> *        [03]           [13]          [23]           [33]           [43]</span></span><br><span class="line"><span class="comment"> *        [04]           [14]          [24]           [34]           [44]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  计算阶段</span></span><br><span class="line"><span class="comment"> *  Step 0: rank r sends block r to rank (r+1) and receives bloc (r-1)</span></span><br><span class="line"><span class="comment"> *  from rank (r-1) [with wraparound].</span></span><br><span class="line"><span class="comment"> *    #     0              1             2              3             4</span></span><br><span class="line"><span class="comment"> *        [00]          [00+10]        [20]           [30]           [40]</span></span><br><span class="line"><span class="comment"> *        [01]           [11]         [11+21]         [31]           [41]</span></span><br><span class="line"><span class="comment"> *        [02]           [12]          [22]          [22+32]         [42]</span></span><br><span class="line"><span class="comment"> *        [03]           [13]          [23]           [33]         [33+43]</span></span><br><span class="line"><span class="comment"> *      [44+04]          [14]          [24]           [34]           [44]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Step 1: rank r sends block (r-1) to rank (r+1) and receives bloc</span></span><br><span class="line"><span class="comment"> *  (r-2) from rank (r-1) [with wraparound].</span></span><br><span class="line"><span class="comment"> *    #      0              1             2              3             4</span></span><br><span class="line"><span class="comment"> *         [00]          [00+10]     [01+10+20]        [30]           [40]</span></span><br><span class="line"><span class="comment"> *         [01]           [11]         [11+21]      [11+21+31]        [41]</span></span><br><span class="line"><span class="comment"> *         [02]           [12]          [22]          [22+32]      [22+32+42]</span></span><br><span class="line"><span class="comment"> *      [33+43+03]        [13]          [23]           [33]         [33+43]</span></span><br><span class="line"><span class="comment"> *        [44+04]       [44+04+14]       [24]           [34]           [44]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Step 2: rank r sends block (r-2) to rank (r+1) and receives bloc</span></span><br><span class="line"><span class="comment"> *  (r-2) from rank (r-1) [with wraparound].</span></span><br><span class="line"><span class="comment"> *    #      0              1             2              3             4</span></span><br><span class="line"><span class="comment"> *         [00]          [00+10]     [01+10+20]    [01+10+20+30]      [40]</span></span><br><span class="line"><span class="comment"> *         [01]           [11]         [11+21]      [11+21+31]    [11+21+31+41]</span></span><br><span class="line"><span class="comment"> *     [22+32+42+02]      [12]          [22]          [22+32]      [22+32+42]</span></span><br><span class="line"><span class="comment"> *      [33+43+03]    [33+43+03+13]     [23]           [33]         [33+43]</span></span><br><span class="line"><span class="comment"> *        [44+04]       [44+04+14]  [44+04+14+24]      [34]           [44]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Step 3: rank r sends block (r-3) to rank (r+1) and receives bloc</span></span><br><span class="line"><span class="comment"> *   (r-3) from rank (r-1) [with wraparound].</span></span><br><span class="line"><span class="comment"> *    #      0              1             2              3             4</span></span><br><span class="line"><span class="comment"> *         [00]          [00+10]     [01+10+20]    [01+10+20+30]     [FULL]</span></span><br><span class="line"><span class="comment"> *        [FULL]           [11]        [11+21]      [11+21+31]    [11+21+31+41]</span></span><br><span class="line"><span class="comment"> *     [22+32+42+02]     [FULL]          [22]         [22+32]      [22+32+42]</span></span><br><span class="line"><span class="comment"> *      [33+43+03]    [33+43+03+13]     [FULL]          [33]         [33+43]</span></span><br><span class="line"><span class="comment"> *        [44+04]       [44+04+14]  [44+04+14+24]      [FULL]         [44]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  分布阶段：ring ALLGATHER with ranks shifted by 1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_base_allreduce_intra_ring</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    <span class="type">int</span> rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == size) <span class="comment">//copy from sbuf to rbuf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//若消息量小于进程数就使用recursive doubling</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt; size) </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ompi_coll_base_allreduce_intra_recursivedoubling</span>(sbuf, rbuf, count, dtype, op, comm, <span class="keyword">module</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">该页面整理了MPI_Allreduce在OpenMPI和MPICH中的设计与最佳算法选择。</summary>
    
    
    
    <category term="并行计算" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="MPI集合通信算法" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/MPI%E9%9B%86%E5%90%88%E9%80%9A%E4%BF%A1%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="MPI" scheme="http://chudod.github.io/tags/MPI/"/>
    
    <category term="并行计算" scheme="http://chudod.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>In-Network Collective Communication</title>
    <link href="http://chudod.github.io/2022/04/10/In-Network_Collective_Summary/"/>
    <id>http://chudod.github.io/2022/04/10/In-Network_Collective_Summary/</id>
    <published>2022-04-09T16:00:00.000Z</published>
    <updated>2022-04-28T07:47:07.949Z</updated>
    
    
    <summary type="html">本文系统整理了利用In-Network(在网计算)方式设计的集合通信。</summary>
    
    
    
    <category term="并行计算" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="In-Network Collectives" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/In-Network-Collectives/"/>
    
    
    <category term="MPI" scheme="http://chudod.github.io/tags/MPI/"/>
    
    <category term="并行计算" scheme="http://chudod.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="在网计算" scheme="http://chudod.github.io/tags/%E5%9C%A8%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="集合通信" scheme="http://chudod.github.io/tags/%E9%9B%86%E5%90%88%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Read Me（导航栏）</title>
    <link href="http://chudod.github.io/2022/04/10/Guiding_Board/"/>
    <id>http://chudod.github.io/2022/04/10/Guiding_Board/</id>
    <published>2022-04-09T16:00:00.000Z</published>
    <updated>2022-04-28T03:32:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建该网站的目的"><a href="#搭建该网站的目的" class="headerlink" title="搭建该网站的目的"></a>搭建该网站的目的</h1><p>小王同学做网站的初衷有两点：第一，为了写一篇综述论文，我做的方向是并行计算和互连网络的结合，由于我自己要写的综述论文涵盖的面非常广，也深入到了MPI和互连网络的最底层，所以难度相当大，为了积累材料和做笔记，我打算自己搭建一个网站；第二，我希望自己整理的工作和思路不仅能够被组里的老师和师兄师姐看到，引起大家的讨论和思考，也希望更多的人能够了解到。随着时间的推移，网站的内容也会越来越多，越来也丰富。我不仅总结了自己读过的论文，自己的部分想法和工作，还记录了自己做过的一些实验以及计算机的一些基础知识，甚至还有一些奇怪的知识、整过的狠活、现在和曾经的生活面貌。这个世界是复杂的，是值得我们奋斗的。  </p><h1 id="网站内容导航"><a href="#网站内容导航" class="headerlink" title="网站内容导航"></a>网站内容导航</h1><h2 id="一、并行计算系列"><a href="#一、并行计算系列" class="headerlink" title="一、并行计算系列"></a>一、并行计算系列</h2><h3 id="1、MPI程序设计基础与并行算法"><a href="#1、MPI程序设计基础与并行算法" class="headerlink" title="1、MPI程序设计基础与并行算法"></a>1、MPI程序设计基础与并行算法</h3><p><a href="https://synchrosky.com/2022/03/30/First_MPI_Program/">MPICH的安装和第一个Allreduce程序</a><br><a href="https://synchrosky.com/2022/03/26/%E5%88%A9%E7%94%A8MPI%E5%AE%9E%E7%8E%B0Cannon%E7%AE%97%E6%B3%95%E5%B9%B6%E8%A1%8C%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/">并行矩阵乘法：Cannon算法</a>  </p><h3 id="2、MPI集合通信算法"><a href="#2、MPI集合通信算法" class="headerlink" title="2、MPI集合通信算法"></a>2、MPI集合通信算法</h3><p><a href="https://synchrosky.com/2022/03/27/MPI_Allreduce_Summary/">MPI_Allreduce的前世今生</a><br><a href="https://synchrosky.com/2022/04/10/MPI_Collectives_Thesis/">MPI集合通信论文整理</a><br><a href="https://synchrosky.com/2022/04/13/OpenMPI&amp;MPICH_Allreduce/">OpenMPI和MPICH中Allreduce的实现</a><br><a href="https://synchrosky.com/2022/03/30/Deeply_Understand_MPI/">深入理解MPI实现</a><br><a href="https://synchrosky.com/2022/04/25/Topology_Aware_Collectives/">高性能计算网络与拓扑感知的集合通信算法</a></p><h3 id="3、在网计算-In-Network-集合通信"><a href="#3、在网计算-In-Network-集合通信" class="headerlink" title="3、在网计算(In-Network)集合通信"></a>3、在网计算(In-Network)集合通信</h3><p><a href="https://synchrosky.com/2022/04/10/In-Network_Collective_Communication/">在网计算集合通信</a><br><a href="https://synchrosky.com/2022/04/10/%E9%9B%86%E5%90%88%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%9C%A8%E7%BD%91%E8%AE%A1%E7%AE%97%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/">在网计算集合通信论文整理</a></p><h2 id="二、计算机基础知识系列"><a href="#二、计算机基础知识系列" class="headerlink" title="二、计算机基础知识系列"></a>二、计算机基础知识系列</h2><h3 id="1、操作系统"><a href="#1、操作系统" class="headerlink" title="1、操作系统"></a>1、操作系统</h3><p><a href="https://synchrosky.com/2022/04/10/OS_Starting/">操作系统启动的皮毛知识</a><br><a href="https://synchrosky.com/2022/04/14/OS_Memory_Management/">操作系统内存管理</a></p><h2 id="三、硬核学者系列"><a href="#三、硬核学者系列" class="headerlink" title="三、硬核学者系列"></a>三、硬核学者系列</h2><p><a href="https://synchrosky.com/2022/04/20/TorstenHeofler/">硬核学者之Trosen Hoefler</a></p><h2 id="四、奇怪知识系列"><a href="#四、奇怪知识系列" class="headerlink" title="四、奇怪知识系列"></a>四、奇怪知识系列</h2><h2 id="五、整活系列"><a href="#五、整活系列" class="headerlink" title="五、整活系列"></a>五、整活系列</h2><p>1、<a href="https://synchrosky.com/2022/03/26/xjtu/">XJTU的旧时光</a>    </p><p>本网站内容持续更新中…<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB8a52193ab1800fc09b72a30eedd0319b?method=download&amp;shareKey=db01fa57b10b434ada861e14c93e6ff2" alt=""></p>]]></content>
    
    
    <summary type="html">本网站内容的基本介绍</summary>
    
    
    
    <category term="导航" scheme="http://chudod.github.io/categories/%E5%AF%BC%E8%88%AA/"/>
    
    
  </entry>
  
  <entry>
    <title>In-Network Collective Communication论文整理</title>
    <link href="http://chudod.github.io/2022/04/10/In_Network_Collectives_Thesis/"/>
    <id>http://chudod.github.io/2022/04/10/In_Network_Collectives_Thesis/</id>
    <published>2022-04-09T16:00:00.000Z</published>
    <updated>2022-04-28T07:47:31.359Z</updated>
    
    
    <summary type="html">本文全面整理In-Network Collective Communication的论文。</summary>
    
    
    
    <category term="并行计算" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="In-Network Collectives" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/In-Network-Collectives/"/>
    
    
    <category term="MPI" scheme="http://chudod.github.io/tags/MPI/"/>
    
    <category term="并行计算" scheme="http://chudod.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="在网计算" scheme="http://chudod.github.io/tags/%E5%9C%A8%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="集合通信" scheme="http://chudod.github.io/tags/%E9%9B%86%E5%90%88%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>MPI集合通信论文整理</title>
    <link href="http://chudod.github.io/2022/04/10/MPI_Collectives_Thesis/"/>
    <id>http://chudod.github.io/2022/04/10/MPI_Collectives_Thesis/</id>
    <published>2022-04-09T16:00:00.000Z</published>
    <updated>2022-04-10T03:48:45.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文全面列举出了MPI集合通信的相关论文，对每篇论文做出一个概述而不是详细介绍，详细的MPI集合通信算法设计可以参考：<a href="https://synchrosky.com/2022/03/27/MPI_Allreduce%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/">MPI_Allreuce的前世今生</a>。  </p><h1 id="MPI集合通信论文"><a href="#MPI集合通信论文" class="headerlink" title="MPI集合通信论文"></a>MPI集合通信论文</h1><h2 id="1、2005-Optimization-of-Collective-Communication-Operations-in-MPICH"><a href="#1、2005-Optimization-of-Collective-Communication-Operations-in-MPICH" class="headerlink" title="1、2005: Optimization of Collective Communication Operations in MPICH"></a><a href="https://journals.sagepub.com/doi/10.1177/1094342005051521">1、2005: Optimization of Collective Communication Operations in MPICH</a></h2><p>经典的$MPI$集合通信综述论文，介绍了常用的集合通信操作和对应的算法：$Allgather$, $Broadcast$, $All$-$to$-$all$, $Reduce$-$Scatter$, $Reduce$和$Allreduce$，并进一步的讨论了 $MPI$_$Reduce$ 和$MPI$_$Allreduce$的优化。评估模型为：$T=\alpha+n\beta$。  </p><h2 id="2、-SC17-Why-is-MPI-so-slow-Analyzing-the-fundamental-limits-in-implementing-MPI-3-1"><a href="#2、-SC17-Why-is-MPI-so-slow-Analyzing-the-fundamental-limits-in-implementing-MPI-3-1" class="headerlink" title="2、(SC17) Why is MPI so slow?: Analyzing the fundamental limits in implementing MPI-3.1"></a><a href="https://dl.acm.org/doi/10.1145/3126908.3126963">2、(SC17) Why is MPI so slow?: Analyzing the fundamental limits in implementing MPI-3.1</a></h2><p>这篇文章主要介绍了MPI-3.1标准的主要制约因素，针对MPI-3.1标准的不足重新设计了MPI-CH4软件栈，实现对于深入理解MPI的实现很有帮助。</p>]]></content>
    
    
    <summary type="html">本文全面列举出了MPI集合通信的相关论文，对每篇论文做出一个概述而不是详细介绍</summary>
    
    
    
    <category term="并行计算" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="MPI集合通信算法" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/MPI%E9%9B%86%E5%90%88%E9%80%9A%E4%BF%A1%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="MPI" scheme="http://chudod.github.io/tags/MPI/"/>
    
    <category term="并行计算" scheme="http://chudod.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>操作系统启动过程简述</title>
    <link href="http://chudod.github.io/2022/04/10/OS_Starting/"/>
    <id>http://chudod.github.io/2022/04/10/OS_Starting/</id>
    <published>2022-04-09T16:00:00.000Z</published>
    <updated>2022-04-14T14:11:21.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、操作系统启动生成的进程树"><a href="#一、操作系统启动生成的进程树" class="headerlink" title="一、操作系统启动生成的进程树"></a>一、操作系统启动生成的进程树</h1><p>下图是我在做实验时调试出来的操作系统生成的进程树，计算机在刚开始启动时执行的是汇编代码，然后执行的第一行C代码是<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_kernel</span><br></pre></td></tr></table></figure><br>在执行这个函数之后，正在执行的程序成为0号进程，0号进程会先后调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__do_fork</span><br><span class="line">do_execve</span><br></pre></td></tr></table></figure><br>两个函数去执行$\verb+fork+$和$\verb+exec+$两个系统调用，生成1号和2号进程，1号进程就是大名鼎鼎的$init$进程，所有用户程序的根进程（包括$shell$进程和用户登录进程等等）。2号进程负责创建和维护所有内核线程（在本图中是960号及之前的进程）。最后0号进程调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpu_dile</span><br></pre></td></tr></table></figure><br>函数进入休眠状态，CPU在没有活跃任务可调度时就执行它。<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBaa78b81deaec02c397484e8a2a5b43d4?method=download&amp;shareKey=69113f8f61e335d1864757cf6d288929" alt="操作系统启动时生成的进程树"></p><h1 id="二、计算机启动过程"><a href="#二、计算机启动过程" class="headerlink" title="二、计算机启动过程"></a>二、计算机启动过程</h1><p>本科做实验时画的图，描绘的时MBR启动的图，计算机先执行BIOS，然后跳转到$\verb+0x7c00+$地址执行MBR，然后执行Loader，完成实模式向保护模式切换、页表初始化等工作，然后进入内核。<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB06869dacb48da066cbcdabfb88241216?method=download&amp;shareKey=69113f8f61e335d1864757cf6d288929" alt="MBR启动过程"></p>]]></content>
    
    
    <summary type="html">这是小王同学的第1篇操作系统知识：OS启动过程简析</summary>
    
    
    
    <category term="计算机基础知识" scheme="http://chudod.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="操作系统" scheme="http://chudod.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://chudod.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解MPI实现</title>
    <link href="http://chudod.github.io/2022/03/30/Deeply_Understand_MPI/"/>
    <id>http://chudod.github.io/2022/03/30/Deeply_Understand_MPI/</id>
    <published>2022-03-29T16:00:00.000Z</published>
    <updated>2022-03-31T09:08:22.101Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章讨论MPI通信栈的各个层次以及制约MPI性能的主要因素。<br><a href="https://dl.acm.org/doi/10.1145/3126908.3126963">(SC17) Why is MPI so slow?: Analyzing the fundamental limits in implementing MPI-3.1</a><br>这篇文章主要介绍了MPI-3.1标准的主要制约因素，对于深入理解MPI的实现很有帮助。其他的优化MPI的论文都是关注于MPI的典型实现（例如在MPICH或者OpenMPI里优化），而这篇文章则关注MPI-3.1标准的优化，并提出了一个基于MPI-3.1标准的高度优化的MPI实现，工作在MPICH的环境下实现的，主要工作是重新设计了MPICH通信栈里的ch4，如下图所示。</p><div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEB53b70dc12111821a8ae1e0f1f1319988?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div><p>MPICH是一个典型的多层次的软件栈。在MPI的用户接口层下面，最上层是“MPI Layer”，执行的都是机器无关代码，往下走是机器相关代码，也被叫做抽象设备层或者设备层，旧的MPICH提供两种设备：CH3（对于大多数平台）以及PAMID（IBM的蓝色基因）。CH4是本文重新设计的设备层，包括CH4 Core和Shmmods（共享内存模式通信）以及Netmods（网络互连模式通信）。一个MPI_PUT操作的控制流如下：（1）在MPI Layer层中检查参数错误、检查描述了访问进程和内存的MPI窗口对象、通信应该使用线程安全路径还是非安全路径；（2）CH4 Core检查局部性，如果目的进程就是自己，CH4 Core直接处理，如果通信发生在同一个节点上，就采用Shmmods，否则采用Netmods，控制流进入模块；（3）在Netmods或者Shmmods中分析操作，并判断是否可以直接在硬件实现还是要基于活动消息回退（没搞懂这个是在干嘛）。比如MPI_PUT操作，在Netmods模式下硬件能直接完成的操作仅限于：连续内存数据的RDMA操作，对于复杂的数据类型会回退到CH4 Core中的活动消息回退处理模块（active-message fallback）。在硬件上完成MPI_PUT操作时会将MPI级别的参数转化为网络级别的参数（比如将MPI中的目标偏移量转化为操作系统的虚拟地址），然后根据对应的MPI操作来完成一个或者多个网络操作。</p>]]></content>
    
    
    <summary type="html">本文主要深入探讨典型MPI通信栈的各个层次以及制约MPI的因素</summary>
    
    
    
    <category term="并行计算" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="MPI软件栈设计" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/MPI%E8%BD%AF%E4%BB%B6%E6%A0%88%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="MPI" scheme="http://chudod.github.io/tags/MPI/"/>
    
    <category term="并行计算" scheme="http://chudod.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>First Allreduce Application</title>
    <link href="http://chudod.github.io/2022/03/30/First_MPI_Program/"/>
    <id>http://chudod.github.io/2022/03/30/First_MPI_Program/</id>
    <published>2022-03-29T16:00:00.000Z</published>
    <updated>2022-04-10T13:21:36.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MPI安装"><a href="#MPI安装" class="headerlink" title="MPI安装"></a>MPI安装</h1><h2 id="Linux安装MPICH"><a href="#Linux安装MPICH" class="headerlink" title="Linux安装MPICH"></a>Linux安装MPICH</h2><p>$MPICH$是$MPI$的一个使用的非常广泛的库。简单的在$linux$中$sudo\ apt-get\ install$就可以安装成功，当然也可以下载$MPICH$源码，可参考<a href="https://mpitutorial.com/tutorials/installing-mpich2/zh_cn/">MPICH安装</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install mpich</span><br></pre></td></tr></table></figure><br>通过在程序中添加<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mpi.h&gt;</span></span></span><br></pre></td></tr></table></figure><br>即可调用$MPICH$，可以参考<a href="https://mpitutorial.com/tutorials/mpi-hello-world/zh_cn/">这里</a>写第一个简单的$MPI\ Hello\ World$程序。<br>$mpicc$和$mpicxx$是$MPICH$的编译器，看名字就知道分别对应$C$和$C++$程序。简单使用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpicc helloworld.c -o helloworld</span><br></pre></td></tr></table></figure><br>就可以编译程序，再使用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpirun -n <span class="number">4</span> helloworld</span><br></pre></td></tr></table></figure><br>就可以运行$mpi$程序，$mpiexec$和$mpirun$是$MPICH$提供的两个解释器，能够运行我们编写的应用程序，其中$mpirun$只能使每个进程运行同一个程序，而$mpiexec$能使不同进程运行不同的程序，如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpiexec -n <span class="number">1</span> program1 : -n <span class="number">2</span> porgram2</span><br></pre></td></tr></table></figure></p><h1 id="Windows安装MPI"><a href="#Windows安装MPI" class="headerlink" title="Windows安装MPI"></a>Windows安装MPI</h1><h2 id="下载MPICH"><a href="#下载MPICH" class="headerlink" title="下载MPICH"></a>下载MPICH</h2><p>在<a href="https://www.mpich.org/downloads/">MPICH官网</a>下载源码包，选择$Windows$系统，然后在这里点击$http$。<img data-src="https://note.youdao.com/yws/api/personal/file/WEB20896ad49caab7166ef314cad41a02b6?method=download&amp;shareKey=904f976c5859bc89c59dc0453602ff98" alt=""><br>再选择这里的安装：<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB7c6b5b95675ec4f841346e261f69ce27?method=download&amp;shareKey=707ee3c6204b8e72dfaa8e511c794021" alt=""><br>把两个安装程序都装上：<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB6d1c0e875e7a9f657caabefebba78720?method=download&amp;shareKey=707ee3c6204b8e72dfaa8e511c794021" alt=""><br>分别点击两个安装程序，生成如下两个文件夹（可以放在D盘，自己命名文件夹）:<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBf74acea7bf53fffaa844e63a7dec88c0?method=download&amp;shareKey=707ee3c6204b8e72dfaa8e511c794021" alt=""></p><h2 id="在Visual-Studio中配置环境"><a href="#在Visual-Studio中配置环境" class="headerlink" title="在Visual Studio中配置环境"></a>在Visual Studio中配置环境</h2><p>在$Visual Studio$中“创建新项目”-&gt;“控制台应用”。我得项目名字叫“MPITest”，然后选择“调试”-&gt;“调试属性”。<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBe948b4c6c4177ceb858b5b701b2c30d5?method=download&amp;shareKey=707ee3c6204b8e72dfaa8e511c794021" alt=""><br>选择“C/C++”-&gt;“预处理器”-&gt;“预处理器定义”-&gt;添加“MPICH_SKIP_MPICXX”<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB20c39cee8383c7ff5aa58051b1813587?method=download&amp;shareKey=707ee3c6204b8e72dfaa8e511c794021" alt=""><br>选择“代码生成”-&gt;“运行库”-&gt;“多线程调试\MTD”：<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB3649df78f08d5e177074bb94203e796c?method=download&amp;shareKey=707ee3c6204b8e72dfaa8e511c794021" alt=""><br>选择“输入”-&gt;“添加附加依赖项”-&gt;添加“msmpi.lib”<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB40a3f1b4bf58bf1355913ab011d39dba?method=download&amp;shareKey=707ee3c6204b8e72dfaa8e511c794021" alt=""><br>选择“VC++目录”-&gt;“包含目录”-&gt;添加“(MPI安装位置)\Microsoft SDKs\Include”；<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB45e6a730d39c84744f498943cede91f3?method=download&amp;shareKey=707ee3c6204b8e72dfaa8e511c794021" alt=""><br>再选择“库目录”-&gt;添加“(MPI安装位置)\Microsoft SDKs\Lib\x64”<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBb24da11e6a4661787def0934cdfbe1fd?method=download&amp;shareKey=707ee3c6204b8e72dfaa8e511c794021" alt=""><br>配置完成。</p><h2 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h2><h3 id="使用cmd终端或者Powershell终端运行"><a href="#使用cmd终端或者Powershell终端运行" class="headerlink" title="使用cmd终端或者Powershell终端运行"></a>使用cmd终端或者Powershell终端运行</h3><p>按照下一节的$Allreduce$积分程序写好代码，然后$VS$里点击运行，生成$.exe$文件，由于$VS$的默认进程数是1，只能运行进程数为1的情况。<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB45f2da6f8a6933d86356422c763a9d35?method=download&amp;shareKey=707ee3c6204b8e72dfaa8e511c794021" alt=""><br>打开cmd终端，在$.exe$文件的目录下输入指令<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpiexec -n <span class="number">4</span> MPITest.exe</span><br></pre></td></tr></table></figure><br>得到结果:<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEB2a2c779942cc9145ed1cb903c51aa7e3?method=download&amp;shareKey=707ee3c6204b8e72dfaa8e511c794021" alt=""></p><h3 id="在VS里配置命令"><a href="#在VS里配置命令" class="headerlink" title="在VS里配置命令"></a>在VS里配置命令</h3><p>复制$MPITest.exe$程序到$C$盘，然后点击“MPITest项目属性”-&gt;“调试”，配置命令行属性如图即可。注意命令参数是“mpiexec.exe”程序所在的文件夹，在最开始生成的两个安装文件包的“Microsoft MPI”里，并且$MPITest.exe$程序一定要拷贝到$C$盘！！！不然$VS$会报错找不到这个$MPITest.exe$程序，不知道为什么会有这个$bug$。<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBf9d84e95565cd0cf872f810f043ea6ed?method=download&amp;shareKey=707ee3c6204b8e72dfaa8e511c794021" alt=""></p><h1 id="First-Allreduce-Program"><a href="#First-Allreduce-Program" class="headerlink" title="First Allreduce Program"></a>First Allreduce Program</h1><p>这里展示调用$MPI$_ $Allreduce$函数来使用梯形积分法求解$\int_{1}^{e}\ln{x}dx$。<br>$Allreduce$操作是$MPI$中最常用的集合通信操作，与之相似的是$Reduce$操作，假设有$p$个进程，每个进程都持有一个含$n$个元素的向量，所有的$p$个进程将自己的向量发送给根进程，根进程收集这些向量计算规约的结果（求和、求最大最小值等等），$Reduce$操作结果保存在根进程，$Allreduce$则将根进程的结果再广播出去。简单的在应用程序中调用$MPI$_$Allreduce$就可以完成上述例程，函数定义如下：<br>程序可以表示为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Allreduce</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> <span class="type">void</span> *sendbuf,      <span class="comment">//存放源数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">void</span> *recvbuf,            <span class="comment">//存放规约结果</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> count,                <span class="comment">//数据个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">            MPI_Datatype datatype,    <span class="comment">//数据类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">            MPI_Op op,                <span class="comment">//规约操作类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">            MPI_Comm comm)</span></span>;           <span class="comment">//一组通信进程</span></span><br></pre></td></tr></table></figure><br>$MPI$_$Reduce$ 和$MPI$_$Allreduce$例程的图解如下所示：</p><div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEB635e35297acaeac7ad5f79fc97142fab?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div><div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEB8453078f33cba2dcd2ba5b49d8b04daf?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div><p>图片源网址和$MPI$_$Allreduce$的入门教程在这里：<a href="https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/">英文版</a>和<a href="https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/zh_cn/">中文版</a> </p><p>利用梯形积分法求解$\int_{1}^{e}\ln{x}dx$的思路是将区间$[1,e]$分成1024个段，一个段对应一个狭小的梯形，面积为$\ln{x_i}\cdot{dx}$，然后将这些梯形相加。$MPI$可以创建多个进程来加速，每个进程计算一部分区间的积分，然后将结果相加起来。在程序中$a$和$b$是整个积分的区间，$local$_ $a$和$local$_$b$是每个进程负责的区间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   eexp(1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  n = <span class="number">1024</span>, local_n;</span><br><span class="line"><span class="type">double</span>  a = <span class="number">1.0</span>, b = e, len;</span><br><span class="line"><span class="type">double</span>  local_a, local_b, sum = <span class="number">0.0</span>, ans, local_ans;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>  <span class="title function_">calc</span><span class="params">(<span class="type">double</span>  local_a, <span class="type">double</span>  local_b, <span class="type">int</span>  local_n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> sum = (<span class="built_in">log</span>(local_a) + <span class="built_in">log</span>(local_b)) / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> xi;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; local_n; i++)</span><br><span class="line">&#123;</span><br><span class="line">xi = local_a + len * i;</span><br><span class="line">sum += <span class="built_in">fabs</span>(<span class="built_in">log</span>(xi));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  sum * len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  comm_size;</span><br><span class="line"><span class="type">int</span>  my_rank;</span><br><span class="line">MPI_Init(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">MPI_Comm_size(MPI_COMM_WORLD, &amp;comm_size);</span><br><span class="line">MPI_Comm_rank(MPI_COMM_WORLD, &amp;my_rank);</span><br><span class="line"></span><br><span class="line">len = (b - a) / n;<span class="comment">//就是dx</span></span><br><span class="line">local_a = a + my_rank * len * (n / comm_size);<span class="comment">//local_a是每个进程负责计算的区间的起始</span></span><br><span class="line">local_b = local_a + len * (n / comm_size);<span class="comment">//local_b是每个进程负责计算的区间的结束</span></span><br><span class="line">local_n = n / comm_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个进程计算自己区间上的积分</span></span><br><span class="line">local_ans = calc(local_a, local_b, local_n);</span><br><span class="line"><span class="comment">//每个进程计算的结果local_ans相加到全局结果ans上</span></span><br><span class="line">MPI_Allreduce(&amp;local_ans, &amp;ans, <span class="number">1</span>, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My rank: %d, Result : %.5f\n&quot;</span>, my_rank, ans);</span><br><span class="line">MPI_Finalize();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在$Linux$中编译时链接上$lm$数学运算库：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mpicc allreduce.c -o allreduce -lm</span><br><span class="line">mpiexec -n <span class="number">4</span> allreduce</span><br></pre></td></tr></table></figure><br>即可得到结果。</p>]]></content>
    
    
    <summary type="html">该篇文章介绍MPICH在Linux和Windows的安装以及一个最简单的Allreduce的例程</summary>
    
    
    
    <category term="并行计算" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="MPI程序设计" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/MPI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="MPI" scheme="http://chudod.github.io/tags/MPI/"/>
    
    <category term="并行计算" scheme="http://chudod.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>MPI_Allreduce的前世今生</title>
    <link href="http://chudod.github.io/2022/03/27/MPI_Allreduce_Summary/"/>
    <id>http://chudod.github.io/2022/03/27/MPI_Allreduce_Summary/</id>
    <published>2022-03-26T16:00:00.000Z</published>
    <updated>2022-05-12T09:30:49.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文介绍$Allreduce$操作在$MPI$中的算法设计和实现，归纳和整理其发展脉络，追溯到最新的研究进展，并分析$MPI$的典型实现$MPICH$库中是怎样实现$Allreduce$例程的。</p><h1 id="Allreduce介绍"><a href="#Allreduce介绍" class="headerlink" title="Allreduce介绍"></a>Allreduce介绍</h1><p>$Allreduce$操作是$MPI$中最常用的集合通信操作，与之相似的是$Reduce$操作，假设有$p$个进程，每个进程都持有一个含$n$个元素的向量，所有的$p$个进程将自己的向量发送给根进程，根进程收集这些向量计算规约的结果（求和、求最大最小值等等），$Reduce$操作结果保存在根进程，$Allreduce$则将根进程的结果再广播出去。简单的在应用程序中调用$\verb+MPI_Allreduce+$就可以完成上述例程，函数定义如下：<br>程序可以表示为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Allreduce</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> <span class="type">void</span> *sendbuf,      <span class="comment">//存放源数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">void</span> *recvbuf,            <span class="comment">//存放规约结果</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> count,                <span class="comment">//数据个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">            MPI_Datatype datatype,    <span class="comment">//数据类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">            MPI_Op op,                <span class="comment">//规约操作类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">            MPI_Comm comm)</span></span>;           <span class="comment">//一组通信进程</span></span><br></pre></td></tr></table></figure><br>$\verb+MPI_Reduce+$和$\verb+MPI_Allreduce+$例程的图解如下所示：</p><div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEB635e35297acaeac7ad5f79fc97142fab?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div><div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEB8453078f33cba2dcd2ba5b49d8b04daf?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div><p>图片源网址和$\verb+MPI_Allreduce+$的入门教程在这里：<a href="https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/">英文版</a>和<a href="https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/zh_cn/">中文版</a>  </p><p>$\verb+MPI_Allreduce+$广泛用于各种并行与分布式应用程序：科学计算、大数据、分布式机器学习、分布式深度学习DNN等等，并且<a href="https://ieeexplore.ieee.org/document/8665758">已有工作</a>表明$\verb+MPI_Allreduce+$是使用频率和运行时间最长的集合通信操作。</p><p>自从$MPI$标准在$1994$年提出以来，$\verb+MPI_Allreduce+$的相关研究从上世纪90年代就已经有很多了，而本文从2005年的一篇综述论文出发，一直追溯到现在，总结$\verb+MPI_Allreduce+$的算法激情燃烧的昨天、老骥伏枥的今天和仰望星空过后的明天。  </p><h1 id="经典数据结构与算法"><a href="#经典数据结构与算法" class="headerlink" title="经典数据结构与算法"></a>经典数据结构与算法</h1><h2 id="0、评估模型：-T-alpha-n-beta"><a href="#0、评估模型：-T-alpha-n-beta" class="headerlink" title="0、评估模型：$T=\alpha+n\beta$"></a>0、评估模型：$T=\alpha+n\beta$</h2><p><a href="https://journals.sagepub.com/doi/10.1177/1094342005051521">2005:Optimization of Collective Communication Operations in MPICH</a>是一篇经典的$MPI$集合通信论文，介绍了常用的集合通信操作和对应的算法：$\verb+Allgather+$, $\verb+Broadcast+$, $\verb+All-to-all+$, $\verb+Reduce-Scatter+$, $\verb+Reduce+$和$\verb+Allreduce+$，并进一步的讨论了$\verb+MPI_Reduce+$和$\verb+MPI_Allreduce+$的优化。我有一门选修课的作业就是将这篇论文全文翻译：<a href="https://note.youdao.com/ynoteshare/index.html?id=1b5cc29dea0aff44f92bdb69a2763e79&amp;type=notebook&amp;_time=1648432853246#/WEB26278ae64dfc1a52e0ece0dd615075f3">翻译原文</a>。<br>这篇文章采用的性能评估模型是$T=\alpha+n\beta$，任意两个节点之间发送一条消息的时间可以用$T=\alpha+n\beta$，其中$\alpha$表示延迟（或者说启动时间），与消息大小无关，而$\beta$表示每个字节的传输时间，$n$表示传输消息的字节数，对于规约操作则用$\gamma$表示每个字节执行规约操作的时间消耗。由于$MPI$基于分布式存储系统，采用$LogP$模型（$L:latency$, $o:overhead$, $g:gap$, $P:processor$），一条长度为$n$的消息传输时间可以计算为:   </p><script type="math/tex; mode=display">T=L+2o+(n-1)b,其中b=min(o, g)</script><p>也就是传输延迟$L$加上两端处理器的处理开销$2o$，和$n$个字节的传输时间，注意$overhead$是任意一个消息的处理开销，$gap$是连续两个字节的传输时间间隔。将上述式子变形，可以得到：  </p><script type="math/tex; mode=display">T=(L+2o-b)+nb=\alpha+n\beta</script><p>这也就是本文性能评估模型的公式，许多文献和教材中也用到了这个公式。我们将$\alpha$称为延迟项$(latency\ term)$，而$n\beta$称为带宽项$(bandwidth\ term)$，并用这个公式来形式化的评估集合通信算法的性能。<br>下面深入讨论这篇论文介绍的集合通信算法。  </p><h2 id="1、-Allgather-操作及算法"><a href="#1、-Allgather-操作及算法" class="headerlink" title="1、$Allgather$操作及算法"></a>1、$Allgather$操作及算法</h2><p>$Allgather$操作的图解如下:  </p><div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEB5c825f77e456600e07ef80d2b87f1e17?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13"/></div>  <p>$\verb+MPI_Allgather+$函数可以参考<a href="https://mpitutorial.com/tutorials/mpi-scatter-gather-and-allgather/">MPI_Allgather</a>。 </p><h3 id="Ring-Algorithm"><a href="#Ring-Algorithm" class="headerlink" title="Ring Algorithm"></a>Ring Algorithm</h3><p>$MPICH$中最初实现$Allgather$操作使用的就是$Ring$算法。</p><div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEBb157d10d3be479fb109ae83144da86e9?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="40%" height="40%"/></div> <p>每一个进程$i$发送本地数据给进程$(i+1)\%p$，并且接受来自$(i-1)\%p$的数据（环绕方式）。以后每一步，进程$i$都向进程$(i+1)\%p$发送上一步接收的来自$(i-1)\%p$号进程的数据。假设有$p$个进程，该算法总共需要$p-1$步来完成。用$n$表示收集的数据总量，每一步每个进程都发送$\frac{n}{p}$的数据，因此算法的时间消耗可以计算为：  </p><script type="math/tex; mode=display">T_{Ring}=(p-1)\alpha+\frac{p-1}{p}n\beta</script><h3 id="Recursive-Doubling"><a href="#Recursive-Doubling" class="headerlink" title="Recursive Doubling"></a>Recursive Doubling</h3><p>递归加倍算法的流程如下图所示：</p><div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEB0cedb39776a1eb420c04698b214a371e?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="50%" height="50%"/></div> <p>在第一步，彼此间距离为1的进程之间互相交换数据，数据量为$\frac{n}{p}$；第二步，彼此间距离为2的进程之间交换进程自己以及上一步从邻居进程接受的数据，数据量为$\frac{2n}{p}$；在第三步，彼此间距离为4的进程之间交换进程自己以及前两步从其他进程接受的数据，数据量为$\frac{4n}{p}$，以此类推，所有进程会在$lgP$步获得所有数据，执行时间为：  </p><script type="math/tex; mode=display">T_{rec\_dbl}=lgP\cdot\alpha+\frac{p-1}{p}n\beta</script><p>其中带宽项和环算法相同，这是因为：</p><script type="math/tex; mode=display">\frac{n}{p}\beta+\frac{2n}{p}\beta+...+\frac{2^{lgP-1}n}{p}\beta=\frac{p-1}{p}n\beta</script><p>这个等式的内在逻辑是任意一个进程总要接受来自其他$p-1$进程发送的总共$(p-1)\cdot\frac{n}{p}$数据量，也就是说带宽项是不能进一步减少的，但是延迟项可以通过优化算法来减少。递归加倍算法能很好的处理进程数量为2的整数幂的情况，但较难处理进程数量非2的幂次的情况。 </p><h3 id="Bruck-Algorithm"><a href="#Bruck-Algorithm" class="headerlink" title="Bruck Algorithm"></a>Bruck Algorithm</h3><p>$Bruck$算法能够很好的处理进程数非2的幂次的情况，算法的执行步骤为$\lceil{lgP}\rceil$步，算法图解如下所示</p><div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEBe58d78d1a74b305f1da143695784f911?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13"/></div> <p>每个进程都有一片大小为$n$的缓存存放数据，在算法的开始，每个进程将本地数据拷贝到缓存的顶部。在第$k$步，进程$i$向目标进程$(i-2^k)\%p$发送本地的所有数据，并将接受的数据（来自进程$(i+2^k)\%p$）添加至本地数据的末尾，一共$\lfloor{lgP}\rfloor$步。如果进程的数量不是2的幂，还需要额外的一步，每个进程向目标进程$(i-2^k)\%p$发送自己缓存头部的$p-2^{\lfloor{lgP}\rfloor}$块数据（前面步骤都是本地全部数据，这里是头部的部分数据），并将接受的数据添加到本地缓存末尾。<br>现在，所有进程都已经获得了全部数据，但是数据并不是以正确的顺序排列在缓存中：进程$i$中的所有数据块都向上偏移了$i$块。因此简单的将所有数据块循环向下移动$i$块就能将数据块调整到正确的位置上。算法的时间开销为：</p><script type="math/tex; mode=display">T_{Bruck}=\lceil{lgP}\rceil\cdot\alpha+\frac{p-1}{p}n\beta</script><p>$Allgather$操作的算法选取策略是：</p><ul><li>当进程数量为2的幂并且发送短消息或者中等规模消息，采用$Recursive\ doubling$算法；</li><li>当发送短消息以及进程数量非2的幂的情况下，采用$Bruck$算法；</li><li>发送大消息，无论进程数量是多少，并且进程数量非2幂且发送中等规模消息，采用$Ring$算法。  </li></ul><h2 id="2、-Broadcast-操作及算法"><a href="#2、-Broadcast-操作及算法" class="headerlink" title="2、$Broadcast$操作及算法"></a>2、$Broadcast$操作及算法</h2><p>广播操作由根进程将根进程中的数据广播给所有进程，对应的是$\verb+MPI_Bcast+$函数，可以参考<a href="https://mpitutorial.com/tutorials/mpi-broadcast-and-collective-communication/">MPI_Bcast</a></p><div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEBa1d3f66081e6d3666838b6ff37186727?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13"/></div> <h3 id="Bionomial-Tree"><a href="#Bionomial-Tree" class="headerlink" title="Bionomial Tree"></a>Bionomial Tree</h3><p>$MPICH$中广播操作最初使用二项树算法。在第一步，根进程$root$向目标进程$(root+\frac{p}{2})\%p$发送数据，进程$(root+\frac{p}{2})\%p$以及根进程成为它们子树的根结点，继续递归执行算法。该算法一共执行$\lceil{\lg{p}}\rceil$步，在每一步所有进程发送的数据量均为$n$，因此算法的时间开销为：</p><script type="math/tex; mode=display">T_{tree}=\lceil{\lg{p}}\rceil\cdot(\alpha+n\beta)</script><h3 id="Scatter-Allgather"><a href="#Scatter-Allgather" class="headerlink" title="Scatter + Allgather"></a>Scatter + Allgather</h3><p>这是一种组合算法，又叫$Van\ de\ Geijn$算法，将$Scatter$和$Allgather$两个操作组合成了$Broadcast$操作。$Scatter$（散播）操作与$Broadcast$操作的对比如下:</p><div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEBc635d7af2913d2a188bcd426165b25b5?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13"/></div> <p>在该算法中，要广播的数据先分成若干份，散播到各个进程中，接着，散播的数据又收集到所有进程中，也就是再执行$\verb+MPI_Allgather+$操作。其中Scatter操作使用二项树算法，时间消耗为：</p><script type="math/tex; mode=display">T_{Scatter}=\lg{p}\cdot\alpha+\frac{p-1}{p}n\beta</script><p>时间消耗和$Allgather$递归加倍算法相同，仔细观察你会发现两者互为逆过程。而$Allgather$操作可以使用递归加倍算法或者环算法，总时间等于两者之和。<br>因此广播操作的二项树算法和$Scatter+Allgather$算法的时间消耗对比如下：</p><script type="math/tex; mode=display">\left\{\begin{matrix} T_{tree}=\lceil{\lg{p}}\rceil\cdot(\alpha+n\beta) \\ {T_{Scatter+Allgather}=(\lg{p}+p-1)\alpha+2\frac{p-1}{p}n\beta} \end{matrix}\right.</script><p>对比两个式子我们可以很容易得到：</p><ul><li>当消息两较小（即$n$较小）或者进程数量少时（小于8），我们使用二项树算法；</li><li>当消息较大时或者进程数量较大时，我们采用$Scatter$+$Allgather$的组合算法。  </li></ul><h2 id="3、-Reduce-Scatter-操作及其算法"><a href="#3、-Reduce-Scatter-操作及其算法" class="headerlink" title="3、$Reduce-Scatter$操作及其算法"></a>3、$Reduce-Scatter$操作及其算法</h2><p>$Reduce-Scatter$操作（多对多规约）是数据规约操作$Reduce$的一个变种，$Reduce$操作的结果保存在根进程中，而$Reduce-Scatter$将结果散发（$Scatter$）给所有进程。</p><h3 id="二项树Reduce-线性Scatter"><a href="#二项树Reduce-线性Scatter" class="headerlink" title="二项树Reduce+线性Scatter"></a>二项树Reduce+线性Scatter</h3><p>在$MPICH$中的老算法中，$Reduce-Scatter$操作先是将所有进程的数据通过二项树规约到$0$号进程，然后通过线性的散发操作将数据分发出去。二项树规约操作的时间为:</p><script type="math/tex; mode=display">\lg{p}\cdot(\alpha+n\beta+n\gamma)</script><p>线性散发操作的时间为：</p><script type="math/tex; mode=display">(p-1)\alpha+(p-1)\cdot\frac{n}{p}\beta</script><p>总的时间为:</p><script type="math/tex; mode=display">T_{old}=(\lg{p}+p-1)\alpha+(\lg{p}+\frac{p-1}{p})n\beta+\lg{p}\cdot{n}\gamma</script><h3 id="Recursive-Halving"><a href="#Recursive-Halving" class="headerlink" title="Recursive Halving"></a>Recursive Halving</h3><p>递归减半算法和前面$Allgather$操作的递归加倍算法互为逆过程。</p><div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEB45d2ca1b81056825d285e44a1ec85910?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13"/></div> <p>在第1步，进程分为2个子集，每一个进程都和与自己间隔$\frac{p}{2}$的进程交换数据：每一个进程发送另一半集合所有进程都所需要的数据，并且接收自己所在进程集合都需要的数据，然后对收集到的数据进行规约操作。在第2步，每一个进程都和与自己间隔$\frac{p}{4}$的进程交换数据。该过程如此递归进行下去，每一步通信数据也递归减半，进行$\lg{p}$步。算法的时间消耗为：</p><script type="math/tex; mode=display">T_{rec\_halv}=\lg{p}\cdot\alpha+\frac{p-1}{p}(n\beta+n\gamma)</script><p>该算法能够正确执行的前提是规约操作是满足交换率的（$commutative$），满足交换律的规约操作使用频率更高，这是由于$\verb+MPI+$定义的许多规约操作都是可交换的，例如$\verb+MPI_SUM+$，$\verb+MPI_MAX+$。如果进程的数量不是2的幂次，我们首先将进程的数量减少到2的幂次，具体做法是最开始的$x$个偶数编号进程发送数据给最近的奇数编号进程（$rank+1$），使得$p-x$为$2$的幂。奇数编号进程对收集的数据执行规约操作，然后这些奇数号进程和其余的$p-2x$个进程（一共$p-x$个）参与递归减半算法中计算自己的结果，最后，前$x$个奇数进程将结果返回给左邻居结点。这样算法的时间为：</p><script type="math/tex; mode=display">T_{rec\_halv}=(\lfloor{\lg{p}\rfloor+2)}\alpha+2n\beta+n(1+\frac{p-1}{p})\gamma</script><h3 id="Pairwise-Exchange"><a href="#Pairwise-Exchange" class="headerlink" title="Pairwise Exchange"></a>Pairwise Exchange</h3><p>成对交换算法适用于规约操作不满足交换律，其思想类似于$Allgather$操作递归加倍算法。在第$1$步，每一对邻居进程交换数据；第$2$步，彼此间距为$2$的进程交换数据；在第$3$步，彼此间距为$4$的进程交换数据，如此进行下去。然而它相较于$Allgather$操作，交换的数据更多。在第一步，进程交换除了自己所需要数据以外的所有数据（$n-\frac{n}{p}$数据量），比方说0号进程把除了块0之外的$1{\sim}(p-1)$块发送给$1$号进程，1号进程发送除块1之外的$0$、$2{\sim}(p-1)$块发送给$0$号进程；第二步，进程交换除了自己和上一步通信进程所拥有数据以外的所有数据（$n-\frac{2n}{p}$）；第三步数据量为（$n-\frac{4n}{p}$）。这样算法执行的时间为：</p><script type="math/tex; mode=display">T_{short}=\lg{p}\cdot\alpha+(\lg{p}-\frac{p-1}{p})(n\beta+n\alpha)</script><p>该算法适用于传输的消息量小于256B的情况。对长消息发送（满足交换律的操作是$\geqslant256KB$，不满足交换律的操作是$\geqslant256B$），我们使用执行$p-1$步的成对交换算法。在第$i$步，每一个进程向$(rank+i)\%p$发送数据，接收来自进程$(rank-i)\%p$的数据，并执行局部规约操作。交换的数据仅仅是用于散发结果的的数据量$\frac{n}{p}$，也就是只需要发送每个进程需要的那一部分数据即可。算法执行需要的时间为：</p><script type="math/tex; mode=display">T_{long}=(p-1)\alpha+\frac{p-1}{p}(n\beta+n\gamma)</script><p>Tips:</p><ul><li>Commutative Operations(满足交换律的操作)：MPI定义的数据归约操作包含$\verb+sum+$、$\verb+min+$、$\verb+max+$、$\verb+MinLoc+$、$\verb+MaxLoc+$、$\verb+(bitwise)OR+$、$\verb+AND+$、$\verb+XOR+$等等，其中有些是满足交换律的，有些不满足，</li><li>Associative Operation(满足结合律的操作)：浮点加法和乘法满足交换律但不满足结合律，因为$(a+b)+c\neq$$a+(b+c)$，例如$10^{20}-(10^{20}+\epsilon)=0$而$10^{20}-10^{20}-\epsilon=-\epsilon$。</li><li>$Recursive$ $Havling$适合于满足交换律的操作，$Recursive$ $Doubling$只适用于满足结合律的操作。  </li></ul><p>$\verb+MPI_Reduce_scatter+$策略：</p><ul><li>当操作满足交换律，消息$&lt;{256KB}$采用递归减半算法，$\geqslant{256KB}$则采用$(p-1)$步的成对交换算法；</li><li>操作不满足交换律，消息$&lt;256B$时采用$\lg{p}$步的成对交换算法，$\geqslant{256B}$时采用$(p-1)$步的成对交换算法。</li></ul><h2 id="4、-Reduce-操作及其算法"><a href="#4、-Reduce-操作及其算法" class="headerlink" title="4、$Reduce$操作及其算法"></a>4、$Reduce$操作及其算法</h2><h3 id="Bionomial-Tree-1"><a href="#Bionomial-Tree-1" class="headerlink" title="Bionomial Tree"></a>Bionomial Tree</h3><p>$MPICH$中老算法采用二项树算法，执行$\lg{p}$步，每步都交换一个进程的所有$n$字节数据并进行规约计算，算法的时间为：</p><script type="math/tex; mode=display">T_{tree}=\lceil{\lg{p}}\rceil(\alpha+n\beta+n\gamma)</script><h3 id="Reduce-scatter-Gather组合算法"><a href="#Reduce-scatter-Gather组合算法" class="headerlink" title="Reduce_scatter+Gather组合算法"></a>Reduce_scatter+Gather组合算法</h3><p>该算法将$Reduce-scatter$和$Gather$两个操作组合成$Reduce$操作，也叫$Rabenseifner$算法。回顾广播操作的$Scatter+Allgather$组合算法，成功将二项树算法的$\lg{p}\cdot{n\beta}$的带宽项减小到了$2{n\beta}$的数量级，$Reduce$操作类似于广播的逆过程，因此也可以采用类似的思想，$Reduce-scatter$和$Gather$组合的$Reduce$算法也可以将二项树算法的$\lg{p}\cdot{n\beta}$的带宽项减小到了$2{n\beta}$的数量级。算法的时间为$Reduce-scatter$（递归减半算法）和$Gather$（二项树算法）操作的总和，计算为:</p><script type="math/tex; mode=display">T_{raben}=2\lg{p}\cdot\alpha+\frac{p-1}{p}(2n\beta+n\gamma)</script><p>策略：</p><ul><li>当消息量小（$&lt;2KB$）时，采用二项树算法；</li><li>当消息量大（$\geqslant2KB$）时，采用$Reduce-scatter$+$Gather$算法。  </li></ul><p>小结：看到这里也应该能摸索出一些规律，大消息发送时（$n$较大）我们要尽量较少带宽项，也就是减少$n\beta$前面的系数，延迟项（也叫启动时间）$\alpha$大一点无所谓；而小消息（$n$较小）发送时我们要尽量较少延迟项。这也就是$Reduce$和$Broadcast$操作选择不同算法时的核心思想。</p><h3 id="Ring-Algorithm-1"><a href="#Ring-Algorithm-1" class="headerlink" title="Ring Algorithm"></a>Ring Algorithm</h3><p>和下面将要介绍的$Ring Allreduce$类似，使用$Reduce-scatter$+$Gather$的方式，但是$Reduce-scatter$只发送一部分数据（$\frac{n}{p}$）给目标进程，且$Gather$阶段使用环算法。</p><h2 id="5、-Allreduce-操作及其算法"><a href="#5、-Allreduce-操作及其算法" class="headerlink" title="5、$Allreduce$操作及其算法"></a>5、$Allreduce$操作及其算法</h2><h3 id="Reduce-Broadcast"><a href="#Reduce-Broadcast" class="headerlink" title="Reduce+Broadcast"></a>Reduce+Broadcast</h3><p>$MPICH$中老算法先将结果$Reduce$到根进程然后再将根进程的结果$Broadcast$到所有进程中。</p><h3 id="Recursive-Doubling-1"><a href="#Recursive-Doubling-1" class="headerlink" title="Recursive Doubling"></a>Recursive Doubling</h3><p>$Allreduce$的递归加倍算法和$Allgather$的递归加倍算法是非常相似的，只是每一步都伴随规约操作且交换的数据量也不同，每次进程间两两交换的数据量都是$n$。因此算法执行的时间为：</p><script type="math/tex; mode=display">T_{rec\_dbl}=\lg{p}(\alpha+n\beta+n\gamma)</script><h3 id="Reduce-scatter-Allgather"><a href="#Reduce-scatter-Allgather" class="headerlink" title="Reduce_scatter+Allgather"></a>Reduce_scatter+Allgather</h3><p>该算法也叫$Rabenseifner$算法。回顾$Reduce$操作我们采用了$Reduce-scatter$+$Gather$算法，这里我们在第二步将$Gather$换成了$Allgather$操作，采用$Reduce-scatter$+$Allgather$算法。算法的总开销为：</p><script type="math/tex; mode=display">T_{raben}=2\lg{p}\cdot\alpha+\frac{p-1}{p}(2n\beta+n\gamma)</script><p>截至目前，上述$Reduce$操作的$Reduce-scatter$+$Gather$算法和$Allgather$操作的$Reduce-scatter$+$Allgather$算法，当进程的数量不是2的幂次的时候需要额外处理。移除$r=p-p^{‘}$个额外进程来将进程数量减少到最接近的2次幂$(p^{‘}=2^{\lfloor{\lg{p}}\rfloor})$。前$2r$个进程（$0$号到$2r-1$号）中，所有的偶数进程将输入向量的后半部分发送给右邻居（$rank+1$），所有的奇数进程将输入向量的前半部分发送给左邻居（$rank-1$）。随后偶数进程对前半部分向量进行规约操作，奇数进程对后半部分向量进行规约操作。奇数进程将规约结果发送给左邻居进程。该步骤结束后，前$2r$个进程的偶数编号进程都拥有了和右邻居进程进行规约的结果，而奇数编号进程不会参与算法的后续过程，这样我们就可以把进程的数量减少到2的幂次：最开始的r个偶数进程和最后面的$p-2r$个进程从$0{\sim}(p^{‘}-1)$编号，是2的幂次。然后这些进程再执行$Reduce-scatter$+$Allgather$算法。最后规约的结果还要发送给第一步就已经移除的$r$个进程，如果是$Reduce$操作，根进程在第一步中就被剔除掉了，那么在$Reduce-scatter$操作之后的第一步，该根进程和邻居进程就要互换位置，这样不会增加额外消耗。<br>下图展示了带有13个进程的$Allreduce$操作算法的例子。输入向量和规约结果被分成了8个部分($A,B,…,H$)，因为$8$是小于且最接近$13$的$2$的幂次，用$A{-}H_{rank}$来表示。前2r个（$r=13-8=5,2r=10$）偶数进程先执行两两$Allreduce$操作，然后前$r$个偶数进程（$0$、$2$、$4$、$6$、$8$号）和剩余的$3$（$p-2r=3$）个进程（$10$、$11$、$12$号）执行$Reduce-scatter+Allgather$，最后，前$r$个偶数进程（$0$、$2$、$4$、$6$、$8$号）将结果发送给前$r$个奇数进程（$1$、$3$、$5$、$7$、$9$号）.<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBca42cd1c5c39305518f9b87e91cbcdb4?method=download&amp;shareKey=0412dcb1d5f95516723864a4f1a48a13" alt=""></p><h3 id="Bionary-Block-Algorithm"><a href="#Bionary-Block-Algorithm" class="headerlink" title="Bionary Block Algorithm"></a>Bionary Block Algorithm</h3><p>叫做二方块算法。该算法能够降低进程数量非2幂时$Reduce-scatter+Allgather$算法的负载不均衡问题。以下图为例，在初始阶段对进程划分为若干块，使每一个块内进程子集的数量为2的方幂。每个块内部执行$Reduce-scatter$操作。然后，从最小的块开始，被划分为若干段做为更高一块的输入，更高的一块对收集过来的数据执行规约操作，如$\boxed{2^0}$块作为$\boxed{2^2}$块的输入，两个块进行规约，注意$\boxed{2^0}$块的4个数据拷贝与$\boxed{2^2}$块规约，然后$\boxed{2^2}$块做为$\boxed{2^3}$块的输入再进行两个块的规约。小的进程块会造成负载不均衡。两个连续块的最大差异，会决定负载不均衡的程度。定义$\delta_{expo,max}$做为两个连续块数量（均为2的幂次）的最大差值，如$100=2^6+2^5+2^2$，则$\delta_{expo,max}=max(6-5,5-2)=3$，如果$\delta_{expo,max}$值很小，那么算法的性能会很好。<br>在算法的第二阶段，是$Allgather$操作。上一个更大的块必须向小块发送数据，如图。</p><p><img data-src="https://note.youdao.com/yws/api/personal/file/WEB493ba0c9657ed9064532a87b08ff8ece?method=download&amp;shareKey=0412dcb1d5f95516723864a4f1a48a13" alt=""></p><h3 id="Ring-Algorithm-2"><a href="#Ring-Algorithm-2" class="headerlink" title="Ring Algorithm"></a>Ring Algorithm</h3><p>环算法，其实就是$Reduce-scatter+Allgather$算法的变形，在$Reduce-scatter$阶段是各个进程直接将一部分数据发送到其目的节点，并且$Allgather$操作使用环算法来执行。<br>借用$\verb+OpenMPI+$中的例子来解释$Ring\ Allreduce$算法。<br>假设有5个进程，则进程的输入数据分成5份，先进行$Computation\ stage$（也就是$Reduce-scatter$）然后是$Distribution\ phase$（也就是$Allgather$的环算法）。</p><div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEBf2832a760d9e4937101fa93ae4410649?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div> <div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEB43f5e95a1868d89cbd317169ea87df53?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div> <div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEB169bdb1ca360203ba6ff2fdee5ddae24?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div> <p>该算法的执行时间为：</p><script type="math/tex; mode=display">T_{ring}=2(p-1)\alpha+\frac{p-1}{p}(2n\beta+n\gamma)</script><h2 id="Allreduce选择最佳算法"><a href="#Allreduce选择最佳算法" class="headerlink" title="Allreduce选择最佳算法"></a>Allreduce选择最佳算法</h2><p>在上面介绍的$Allreduce$的$5$种算法中根据进程数量和消息大小来选择不同算法，这张图是展示不同进程数量和消息大小对应的最佳算法（对$\verb+MPI_DOUBLE+$型的数据进行$\verb+MPI_SUM+$求和操作）。$havling+doubling$就是$Reduce-scatter+Allgather$算法。</p><div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEBcc34716f4289d3c74ac7e0bd65786af4?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div> <p>这个是消息大小为$32KB$时对$\verb+MPI_DOUBLE+$型的数据进行$\verb+MPI_SUM+$求和操作不同算法的带宽。</p><div style="align: center"><img data-src="https://note.youdao.com/yws/api/personal/file/WEBa4ff21d874a476bc6a4110496d8d7bbc?method=download&shareKey=0412dcb1d5f95516723864a4f1a48a13" width="70%" height="70%"/></div> <p>策略：</p><ul><li>对于短消息，使用$Recursive Doubling$算法;</li><li>对于长消息，先进行$Reduce-scatter$（$Recursive-halving$算法），再进行$Allgather$（$Recursive\ Doubling$算法）。</li></ul><p>后面的三种方法只是进一步优化，没有在$\verb+MPICH+$里集成。</p><h1 id="Allreduce算法的评估和对比"><a href="#Allreduce算法的评估和对比" class="headerlink" title="Allreduce算法的评估和对比"></a>Allreduce算法的评估和对比</h1><p>常用的经典$Allreduce$算法的消耗评估模型：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Allreduce Algorithm</th><th style="text-align:left">Cost Model</th><th style="text-align:left">Efficient Bandwidth</th></tr></thead><tbody><tr><td style="text-align:left">Reduce + Broadcast</td><td style="text-align:left">$2\lceil{\lg{p}}\rceil(\alpha+n\beta+n\gamma)$</td><td style="text-align:left">$\frac{B}{2}$</td></tr><tr><td style="text-align:left">Recursive Doubling</td><td style="text-align:left">$\lg{p}(\alpha+n\beta+n\gamma)$</td><td style="text-align:left">…</td></tr><tr><td style="text-align:left">Reduce-Scatter + Allgather</td><td style="text-align:left">$2\lg{p}\cdot\alpha+\frac{p-1}{p}(2n\beta+n\gamma)$</td><td style="text-align:left">…</td></tr><tr><td style="text-align:left">Binary Block</td><td style="text-align:left">…</td><td style="text-align:left">…</td></tr><tr><td style="text-align:left">Ring Algorithm</td><td style="text-align:left">$2(p-1)\alpha+\frac{p-1}{p}(2n\beta+n\gamma)$</td><td style="text-align:left">$\frac{nB}{2(n-1)B}$</td></tr></tbody></table></div><h1 id="OpenMPI和MPICH中的Allreduce算法"><a href="#OpenMPI和MPICH中的Allreduce算法" class="headerlink" title="OpenMPI和MPICH中的Allreduce算法"></a>OpenMPI和MPICH中的Allreduce算法</h1><h2 id="1、OpenMPI-4-1-2的MPI-Allreduce实现"><a href="#1、OpenMPI-4-1-2的MPI-Allreduce实现" class="headerlink" title="1、OpenMPI-4.1.2的MPI_Allreduce实现"></a>1、OpenMPI-4.1.2的MPI_Allreduce实现</h2><p>$\verb+OpenMPI-4.1.2+$是最新版本的$\verb+OpenMPI+$，算法的具体选择在$\verb+ompi/mca/coll/tuned/coll_tuned_decision_fixed.c+$和$\verb+ompi/mca/coll/tuned/coll_tuned_decision_dynamic.c+$文件里，用户可以指定规则以及选择使用的算法，并且$\verb+OpenMPI+$使用了6种算法，分别是<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Algorithms:</span><br><span class="line">   &#123;<span class="number">1</span>, <span class="string">&quot;basic_linear&quot;</span>&#125;: Reduce + Broadcast</span><br><span class="line">   &#123;<span class="number">2</span>, <span class="string">&quot;nonoverlapping&quot;</span>&#125;: Reduce +Broadcast</span><br><span class="line">   &#123;<span class="number">3</span>, <span class="string">&quot;recursive_doubling&quot;</span>&#125;: Recursive Doubling</span><br><span class="line">   &#123;<span class="number">4</span>, <span class="string">&quot;ring&quot;</span>&#125;: Ring(Segmented Messages) + Allgather(Ring)</span><br><span class="line">   &#123;<span class="number">5</span>, <span class="string">&quot;segmented_ring&quot;</span>&#125;: Segmented Ring</span><br><span class="line">   &#123;<span class="number">6</span>, <span class="string">&quot;rabenseifner&quot;</span>&#125;: Reduce-Scatter + Allgather</span><br><span class="line">   <span class="comment">/* Currently, ring, segmented ring, and rabenseifner do not support non-commutative operations. */</span></span><br></pre></td></tr></table></figure><br>默认使用$\verb+/coll_tuned_decision_fixed.c+$里的规则（固定算法选择规则），具体的选择方法如下(原代码是100多行的$else-if$，贼暴力)：<br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBef75c5797a8fe9a7d3afe7d9f84db3a2?method=download&amp;shareKey=0412dcb1d5f95516723864a4f1a48a13" alt=""><br><img data-src="https://note.youdao.com/yws/api/personal/file/WEBe38b3f100dd6599ec413faa1ee25edcf?method=download&amp;shareKey=0412dcb1d5f95516723864a4f1a48a13" alt=""><br>除了默认的规则之外，用户还可以指定参数来选择对应的算法。<br>函数选择逻辑：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态算法选择规则</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ompi_coll_tuned_allreduce_intra_dec_dynamic</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果指定了filebased rules(暂不知道这是啥);</span></span><br><span class="line">    <span class="keyword">if</span> (tuned_module-&gt;com_rules[ALLREDUCE])</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> algorithm = ompi_coll_tuned_get_target_method_params();</span><br><span class="line">        <span class="keyword">if</span>(algorithm) <span class="keyword">return</span> ompi_coll_tuned_allreduce_intra_do_this(..., algorithm, ...)</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">switch</span> (algorithm) &#123;</span><br><span class="line">                <span class="keyword">case</span> (<span class="number">0</span>): <span class="keyword">return</span> ompi_coll_tuned_allreduce_intra_dec_fixed();</span><br><span class="line">                <span class="keyword">case</span> (<span class="number">1</span>): <span class="keyword">return</span> ompi_coll_base_allreduce_intra_basic_linear();</span><br><span class="line">                <span class="keyword">case</span> (<span class="number">2</span>): <span class="keyword">return</span> ompi_coll_base_allreduce_intra_nonoverlapping();</span><br><span class="line">                <span class="keyword">case</span> (<span class="number">3</span>): <span class="keyword">return</span> ompi_coll_base_allreduce_intra_recursivedoubling();</span><br><span class="line">                <span class="keyword">case</span> (<span class="number">4</span>): <span class="keyword">return</span> ompi_coll_base_allreduce_intra_ring();</span><br><span class="line">                <span class="keyword">case</span> (<span class="number">5</span>): <span class="keyword">return</span> ompi_coll_base_allreduce_intra_ring_segmented();</span><br><span class="line">                <span class="keyword">case</span> (<span class="number">6</span>): <span class="keyword">return</span> ompi_coll_base_allreduce_intra_redscat_allgather();</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果用户指定了算法;</span></span><br><span class="line">    <span class="keyword">if</span> (tuned_module-&gt;user_forced[ALLREDUCE].algorithm)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ompi_coll_tuned_allreduce_intra_do_this(..., algorithm, ...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若用户没指定算法，则使用固定规则</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ompi_coll_tuned_allreduce_intra_dec_fixed(...)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> ompi_coll_tuned_allreduce_intra_dec_fixed (...)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//100多行的if-else, 根据进程数量和消息量确定algorithm(从1~6选一个值)</span></span><br><span class="line">            <span class="keyword">return</span> ompi_coll_tuned_allreduce_intra_do_this (..., algorithm, ...);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2、MPICH-4-0-2的MPI-Allreduce实现"><a href="#2、MPICH-4-0-2的MPI-Allreduce实现" class="headerlink" title="2、MPICH-4.0.2的MPI_Allreduce实现"></a>2、MPICH-4.0.2的MPI_Allreduce实现</h2><p>$MPI$应用程序在调用$\verb+MPI_Allreduce+$时执行的主要算法、主要函数以及选择逻辑如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Algorithm:</span></span><br><span class="line"><span class="comment">        Intra Communication:</span></span><br><span class="line"><span class="comment">            Recursive Doubling;</span></span><br><span class="line"><span class="comment">            Reduce-scatter + Allgather</span></span><br><span class="line"><span class="comment">            Nb(Nonblocking Allreduce + Wait)</span></span><br><span class="line"><span class="comment">            Smp(Local Reduce + Bcast)</span></span><br><span class="line"><span class="comment">        Inter Communication:</span></span><br><span class="line"><span class="comment">            Reduce-exchange + Bcast</span></span><br><span class="line"><span class="comment">            Nb(Nonblocking Allreduce + Wait)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MPI_Allreduce</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sendbuf, <span class="type">void</span> *recvbuf, <span class="type">int</span> count, MPI_Datatype datatype, MPI_Op op, MPI_Comm comm)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    MPIR_Allreduce(sendbuf, recvbuf, count, datatype, op, comm_ptr, &amp;errflag)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        MPIR_Allreduce_impl(sendbuf, recvbuf, count, datatype, op, comm_ptr, &amp;errflag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="comment">/*intra communicator*/</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span>(intra_alrogithm)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> intra_recursive_doubling:</span><br><span class="line">                        MPIR_Allreduce_intra_recursive_doubling(...);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> intra_reduce_scatter_allgather:</span><br><span class="line">                        MPIR_Allreduce_intra_reduce_scatter_allgather(...);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> nb:</span><br><span class="line">                        MPIR_Allreduce_allcomm_nb(...);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> intra_smp:</span><br><span class="line">                        MPIR_Allreduce_intra_smp(...);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="keyword">auto</span>:</span><br><span class="line">                        MPIR_Allreduce_allcomm_auto(...)</span><br><span class="line">                        &#123;</span><br><span class="line">                            MPII_Csel_container_s *cnt = MPIR_Csel_search(comm_ptr-&gt;csel_comm, coll_sig);</span><br><span class="line">                            <span class="keyword">switch</span> (cnt-&gt;id)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">case</span> intra_recursive_doubling:</span><br><span class="line">                                    MPIR_Allreduce_intra_recursive_doubling(...);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> intra_reduce_scatter_allgather:</span><br><span class="line">                                    MPIR_Allreduce_intra_reduce_scatter_allgather(...);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> intra_smp:</span><br><span class="line">                                    MPIR_Allreduce_intra_smp(...);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> inter_reduce_exchange_bcast:</span><br><span class="line">                                    MPIR_Allreduce_inter_reduce_exchange_bcast(...);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> nb:</span><br><span class="line">                                    MPIR_Allreduce_allcomm_nb(...)</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        MPIR_Iallreduce(...);       <span class="comment">/*Nonblocking Allreduce*/</span></span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">/*inter communicator*/</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span>(inter_algorithm)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> inter_reduce_exchange_bcast:</span><br><span class="line">                        MPIR_Allreduce_inter_reduce_exchange_bcast(...);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> nb:</span><br><span class="line">                        MPIR_Allreduce_allcomm_nb(...);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="keyword">auto</span>:</span><br><span class="line">                        MPIR_Allreduce_allcomm_auto(...);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">该文章系统整理了MPI Allreduce的算法设计，从2005年及更早以前的MPI集合通信算法开始整理，并且跟进了最新的集合通信算法设计。</summary>
    
    
    
    <category term="并行计算" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="MPI集合通信算法" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/MPI%E9%9B%86%E5%90%88%E9%80%9A%E4%BF%A1%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="MPI" scheme="http://chudod.github.io/tags/MPI/"/>
    
    <category term="并行计算" scheme="http://chudod.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Cannon矩阵乘法</title>
    <link href="http://chudod.github.io/2022/03/26/Cannon/"/>
    <id>http://chudod.github.io/2022/03/26/Cannon/</id>
    <published>2022-03-25T16:00:00.000Z</published>
    <updated>2022-04-10T13:21:46.106Z</updated>
    
    <content type="html"><![CDATA[<p>$Cannon$算法是并行矩阵乘法的经典算法，将多个处理器排列成二维网格，采用二维块划分的方法将矩阵分给不同的处理器计算各自的局部结果，以此来加速计算。在本文中，为方便起见，示例程序中的矩阵均为$n$阶方阵，处理器的数量为2的幂次，确保每个矩阵得到的局部矩阵的元素个数相同。</p><h1 id="一、二维矩阵串行乘法"><a href="#一、二维矩阵串行乘法" class="headerlink" title="一、二维矩阵串行乘法"></a>一、二维矩阵串行乘法</h1><p>两个$n$维方阵的乘法$A \cdot B = C$的串行计算公式为：</p><script type="math/tex; mode=display">C_{ij} = \sum_{k=0}^{n-1} A_{ik} \cdot B_{kj}\,.</script><p>程序可以表示为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Multiply</span><span class="params">(<span class="type">double</span>* A, <span class="type">double</span>* B, <span class="type">double</span>* C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">C[i * n + j] += A[i * n + k] * B[j + k * n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>程序将二维矩阵用一维矩阵线性展开，用一维数组来模拟二维数组。</p><h1 id="二、Cannon算法"><a href="#二、Cannon算法" class="headerlink" title="二、Cannon算法"></a>二、Cannon算法</h1><p>并行化二维矩阵乘法的一种思想是二维块划分方法，将$p\,$ 个进程（$p\,$为完全平方数）排列成$\sqrt[]{p}\times\sqrt[]{p}\,$二维网格，然后将矩阵$A、B、C\,$都分成$\sqrt[]{p}\times\sqrt[]{p}\,$ 块，均匀分布在网格上，矩阵第$(i,j)\,$个子块分别记为$A_{ij}\,$、$B_{ij}\,$、$C_{ij}\,$，存储在二维进程网格上坐标为$(i,j)\,$的进程$P_{ij}\,$上。计算$C_{ij}\,$时要将$A_{ik}\,$(第$i\,$行进程上的所有$A\,$的子块)和$B_{kj}\,$(第$j\,$列进程上的所有$B\,$的子块)都收集到进程$P_{ij}\,$上，再计算$C_{ij}\,$，公式可以表达为：</p><script type="math/tex; mode=display">C_{ij} = \sum_{k=0}^{\sqrt[]{p}-1} A_{ik} \cdot B_{kj}</script><p>如下图所示：<br><img data-src="https://img-blog.csdnimg.cn/d00915586a8d405c973cfd0903f821b7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qWa5Zu95Luk5bC5,size_30,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="二维块划分"></p><p>然而每一个进程都重复收集$A_{ik}\,$和$B_{kj}\,$会造成空间的大量浪费，时间效率也比较低，于是有了更高效的$Canon\,$算法，其表达式为：</p><script type="math/tex; mode=display">C_{ij} = \sum_{k=0}^{\sqrt[]{p}-1} A_{i,(i+j+k)\%\sqrt[]{p}} \cdot B_{(i+j+k)\%\sqrt[]{p},j}</script><p>$Canon\,$算法基本思想是，每一个进程只存储$A\,$、$B\,$、$C\,$矩阵的一个子块，本地相对应的$A\,$、$B\,$子块相乘后将结果累加到本地$C\,$子块上，然后再与其他进程交换$A\,$、$B\,$子块，继续相乘将结果累加到本地$C\,$子块上。但是要保证对应的$A\,$、$B\,$子块相乘，不能错位，我们注意到，在最开始，$P_{ij}\,$上的$A\,$为所在行的第$j\,$个，$B\,$为所在列的第$i\,$个，$A\,$和$B\,$子块并不对应，因此将一行上的$A\,$子块循环向左移动$i\,$格，一列上的$B\,$子块循环向上移动$j\,$格，这样$A\,$和$B\,$子块就能对应了，以后每执行一次计算，每行所有$A\,$子块循环向左移动1格，每列上的$B\,$子块循环向上移动1格，$A\,$、$B\,$子块相乘的结果累加在本地的$C\,$子块上。<br><img data-src="https://img-blog.csdnimg.cn/4e1f8ac94d8e4de89df2fbd4707042fa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qWa5Zu95Luk5bC5,size_30,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="排列"></p><p>算法的个步骤表示如下：</p><h2 id="1、第一次重排列"><a href="#1、第一次重排列" class="headerlink" title="1、第一次重排列"></a>1、第一次重排列</h2><p>$k=0$时，$A_{i,(i+j)\%\sqrt[]{p}}$并不处于$P_{ij}\,$上，需要对齐，于是$A_{i,(i+j)\%\sqrt[]{p}}$传送到$P_{ij}\,$上，具体的实现方式是，二维网格上每一行的进程都将$A\,$子块循环向左移位，第$i\,$行的所有进程将$A\,$子块循环向左移位$i\,$个单位；同时$B_{(i+j)\%\sqrt[]{p},j}$并不处于$P_{ij}\,$上，$B_{(i+j)\%\sqrt[]{p},j}$传送到$P_{ij}\,$上，第$j\,$列的所有进程将$B\,$子块循环向上移位$j\,$个单位，如下图所示：<br><img data-src="https://img-blog.csdnimg.cn/8b687e17cec04361b3581c9ba7c50838.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qWa5Zu95Luk5bC5,size_30,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="初始排列"><br>得到的第一次重排列后的矩阵排列为：<br><img data-src="https://img-blog.csdnimg.cn/af16cd39d9ef459b96bdef69b410355b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qWa5Zu95Luk5bC5,size_30,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="第一次重排列后"><br>每个进程得到初次重排列后的$A\,$、$B\,$子块后，将$A\,$、$B\,$子块相乘的结果累加在本地的$C\,$子块上。</p><h2 id="2、后续重排列"><a href="#2、后续重排列" class="headerlink" title="2、后续重排列"></a>2、后续重排列</h2><p>以后每进行一次计算，每行进程的$A\,$子块都循环向左移动一个单位，每列进程的$B\,$子块都循环的向上移动一个单位，如下图所示，$A\,$、$B\,$子块相乘的结果累加在本地的$C\,$子块上，该步骤重复$\sqrt[]{p}-1,$次。<br><img data-src="https://img-blog.csdnimg.cn/643bf8d4f65c444288bc7e7eae8314fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qWa5Zu95Luk5bC5,size_35,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="重排列"><br>最后进程$P_{ij}\,$上能够得到本地的结果$C_{ij}\,$。</p><h1 id="三、程序实现"><a href="#三、程序实现" class="headerlink" title="三、程序实现"></a>三、程序实现</h1><h2 id="1、创建二维进程拓扑结构"><a href="#1、创建二维进程拓扑结构" class="headerlink" title="1、创建二维进程拓扑结构"></a>1、创建二维进程拓扑结构</h2><p>创建进程二维拓扑结构的函数为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dims[<span class="number">0</span>] = dims[<span class="number">1</span>] = <span class="built_in">sqrt</span>(comm_size);</span><br><span class="line">periods[<span class="number">0</span>] = periods[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">MPI_Cart_create(MPI_COMM_WORLD, <span class="number">2</span>, dims, periods, <span class="number">1</span>, &amp;comm_2d);</span><br></pre></td></tr></table></figure><br>$comm_size\,$为进程的总数量，$dims[2]\,$数组表示二维拓扑结构中每一维的大小，$period[2]\,$全部设置成1，表示拓扑结构的第$i\,$维有环绕接。这样我们得到了新的进程通讯器$comm_2d\,$。由于每一个进程都会被分配一个进程号以及进程坐标，从进程号获取进程坐标的函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MPI_Cart_coords(comm_2d, myrank, <span class="number">2</span>, mycoords);</span><br></pre></td></tr></table></figure><br>$myrank\,$是进程序号，$mycoords\,$是大小为2的一维数组。</p><h2 id="2、输入输出矩阵"><a href="#2、输入输出矩阵" class="headerlink" title="2、输入输出矩阵"></a>2、输入输出矩阵</h2><p>输入输出矩阵均为$8\times8\,$矩阵，$A\,$、$B\,$矩阵均为正交矩阵，且$B=A^{T}\,$，$A\,$矩阵为：<br><img data-src="https://img-blog.csdnimg.cn/26b328173bcf48a1bb1d0c38f6439597.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qWa5Zu95Luk5bC5,size_30,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="A矩阵"><br>计算结果应该可以得到一个单位矩阵。</p><h2 id="3、主程序"><a href="#3、主程序" class="headerlink" title="3、主程序"></a>3、主程序</h2><p>每个进程保存的本地矩阵子块分别为$local_A\,$、$local_B\,$、$local_C\,$，方便起见，进程的数量设为1、4、16、64这4种情况中的一种。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi acos(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> myrank, comm_size, srcrank, dstrank;</span><br><span class="line"><span class="type">int</span> dims[<span class="number">2</span>], periods[<span class="number">2</span>], mycoords[<span class="number">2</span>], coords[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n = <span class="number">8</span>, local_n;</span><br><span class="line">MPI_Comm comm_2d;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Multiply</span><span class="params">(<span class="type">double</span>* A, <span class="type">double</span>* B, <span class="type">double</span>* C, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GenerateData</span><span class="params">(MPI_Comm comm_2d, <span class="type">double</span>* local_A, <span class="type">double</span>* local_B)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Cannon</span><span class="params">(MPI_Comm comm_2d, <span class="type">double</span>* local_A, <span class="type">double</span>* local_B, <span class="type">double</span>* local_C)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GatherResult</span><span class="params">(MPI_Comm comm_2d, <span class="type">double</span>* local_C)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span>* local_A, * local_B, * local_C;</span><br><span class="line"></span><br><span class="line">MPI_Init(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">MPI_Comm_size(MPI_COMM_WORLD, &amp;comm_size);</span><br><span class="line">MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myrank == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Number of Process: %d\n&quot;</span>, comm_size);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> start = MPI_Wtime();</span><br><span class="line"></span><br><span class="line">dims[<span class="number">0</span>] = dims[<span class="number">1</span>] = <span class="built_in">sqrt</span>(comm_size);</span><br><span class="line">periods[<span class="number">0</span>] = periods[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">MPI_Cart_create(MPI_COMM_WORLD, <span class="number">2</span>, dims, periods, <span class="number">1</span>, &amp;comm_2d);</span><br><span class="line"></span><br><span class="line">MPI_Comm_rank(comm_2d, &amp;myrank);</span><br><span class="line">MPI_Cart_coords(comm_2d, myrank, <span class="number">2</span>, mycoords);</span><br><span class="line"></span><br><span class="line">local_n = n / dims[<span class="number">0</span>];</span><br><span class="line">local_A = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line">local_B = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line">local_C = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"><span class="built_in">memset</span>(local_A, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"><span class="built_in">memset</span>(local_B, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"><span class="built_in">memset</span>(local_C, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"></span><br><span class="line">GenerateData(comm_2d, local_A, local_B);</span><br><span class="line">Cannon(comm_2d, local_A, local_B, local_C);</span><br><span class="line">GatherResult(comm_2d, local_C);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> end = MPI_Wtime();</span><br><span class="line"><span class="keyword">if</span>(myrank == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Running time: %.2f seconds...\n&quot;</span>, end - start);</span><br><span class="line"></span><br><span class="line">MPI_Comm_free(&amp;comm_2d);</span><br><span class="line">MPI_Finalize();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4、Cannon算法主函数"><a href="#4、Cannon算法主函数" class="headerlink" title="4、Cannon算法主函数"></a>4、Cannon算法主函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Cannon</span><span class="params">(MPI_Comm comm_2d, <span class="type">double</span>* local_A, <span class="type">double</span>* local_B, <span class="type">double</span>* local_C)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> uprank, downrank, leftrank, rightrank;</span><br><span class="line">MPI_Status status;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算左边一格的（目标）进程序号leftrank，和右边一格的（源）进程序号rightrank</span></span><br><span class="line">coords[<span class="number">0</span>] = mycoords[<span class="number">0</span>];</span><br><span class="line">coords[<span class="number">1</span>] = (mycoords[<span class="number">1</span>] - <span class="number">1</span>) % dims[<span class="number">1</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;leftrank);</span><br><span class="line">coords[<span class="number">1</span>] = (mycoords[<span class="number">1</span>] + <span class="number">1</span>) % dims[<span class="number">1</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;rightrank);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算向上一格的（目标）进程序号uprank，和向下一格的（源）进程序号downrank</span></span><br><span class="line">coords[<span class="number">0</span>] = (mycoords[<span class="number">0</span>] - <span class="number">1</span>) % dims[<span class="number">0</span>];</span><br><span class="line">coords[<span class="number">1</span>] = mycoords[<span class="number">1</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;uprank);</span><br><span class="line">coords[<span class="number">0</span>] = (mycoords[<span class="number">0</span>] + <span class="number">1</span>) % dims[<span class="number">0</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;downrank);</span><br><span class="line"></span><br><span class="line"><span class="comment">//A矩阵第一次重排列</span></span><br><span class="line">coords[<span class="number">0</span>] = mycoords[<span class="number">0</span>];</span><br><span class="line">coords[<span class="number">1</span>] = (mycoords[<span class="number">1</span>] - mycoords[<span class="number">0</span>]) % dims[<span class="number">1</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;dstrank);</span><br><span class="line">coords[<span class="number">1</span>] = (mycoords[<span class="number">1</span>] + mycoords[<span class="number">0</span>]) % dims[<span class="number">1</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;srcrank);</span><br><span class="line"><span class="keyword">if</span> (myrank != dstrank)</span><br><span class="line">&#123;</span><br><span class="line">MPI_Sendrecv_replace(local_A, local_n * local_n, MPI_DOUBLE, dstrank, <span class="number">0</span>, srcrank, <span class="number">0</span>, comm_2d, &amp;status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B矩阵第一次重排列</span></span><br><span class="line">coords[<span class="number">1</span>] = mycoords[<span class="number">1</span>];</span><br><span class="line">coords[<span class="number">0</span>] = (mycoords[<span class="number">0</span>] - mycoords[<span class="number">1</span>]) % dims[<span class="number">0</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;dstrank);</span><br><span class="line">coords[<span class="number">0</span>] = (mycoords[<span class="number">0</span>] + mycoords[<span class="number">1</span>]) % dims[<span class="number">0</span>];</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;srcrank);</span><br><span class="line"><span class="keyword">if</span> (myrank != dstrank)</span><br><span class="line">&#123;</span><br><span class="line">MPI_Sendrecv_replace(local_B, local_n * local_n, MPI_DOUBLE, dstrank, <span class="number">0</span>, srcrank, <span class="number">0</span>, comm_2d, &amp;status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Multiply(local_A, local_B, local_C, local_n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> time = <span class="number">0</span>; time &lt; dims[<span class="number">0</span>] - <span class="number">1</span>; time++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//local_A循环往左滚动一格</span></span><br><span class="line">MPI_Sendrecv_replace(local_A, local_n * local_n, MPI_DOUBLE, leftrank, <span class="number">0</span>, rightrank, <span class="number">0</span>, comm_2d, &amp;status);</span><br><span class="line"></span><br><span class="line"><span class="comment">//local_B循环往上滚动一个</span></span><br><span class="line">MPI_Sendrecv_replace(local_B, local_n * local_n, MPI_DOUBLE, uprank, <span class="number">0</span>, downrank, <span class="number">0</span>, comm_2d, &amp;status);</span><br><span class="line"></span><br><span class="line">Multiply(local_A, local_B, local_C, local_n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Multiply</span><span class="params">(<span class="type">double</span>* A, <span class="type">double</span>* B, <span class="type">double</span>* C, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line">C[i * n + j] += A[i * n + k] * B[j + k * n];</span><br><span class="line">Sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中$MPI_Cart_rank\,$用于将进程坐标转换为进程号，$MPI_Sendrecv_replace\,$函数可以视为$MPI_Send$以及$MPI_Recv\,$函数的组合，用于在一个绕接环中，每一个进程向目标进程$dstrank$发送数据，并接受来自$srcrank$源进程的数据，并且在收发数据中所有进程使用的都是同一个缓存。使用该函数可以实现$A$、$B$子块的循环移位。</p><h2 id="5、生成数据并分发到各进程的函数"><a href="#5、生成数据并分发到各进程的函数" class="headerlink" title="5、生成数据并分发到各进程的函数"></a>5、生成数据并分发到各进程的函数</h2><p>0号进程将$A$、$B$矩阵的数据放入$bufferA$、$bufferB$中再发送给对应进程的$local_A$、$local_B$中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GenerateData</span><span class="params">(MPI_Comm comm_2d, <span class="type">double</span>* local_A, <span class="type">double</span>* local_B)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mycoords[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; mycoords[<span class="number">1</span>] == <span class="number">0</span>)<span class="comment">//0号进程生成和发送数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> A[<span class="number">8</span> * <span class="number">8</span>] = &#123;</span><br><span class="line"><span class="built_in">cos</span>(pi / <span class="number">6</span>), -<span class="built_in">sin</span>(pi / <span class="number">6</span>), <span class="number">0</span>, <span class="number">0</span> , <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="built_in">sin</span>(pi / <span class="number">6</span>), <span class="built_in">cos</span>(pi / <span class="number">6</span>), <span class="number">0</span>, <span class="number">0</span> , <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="built_in">cos</span>(pi / <span class="number">4</span>), -<span class="built_in">sin</span>(pi / <span class="number">4</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sin</span>(pi / <span class="number">4</span>), <span class="built_in">cos</span>(pi / <span class="number">4</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">cos</span>(pi / <span class="number">6</span>), -<span class="built_in">sin</span>(pi / <span class="number">6</span>), <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sin</span>(pi / <span class="number">6</span>), <span class="built_in">cos</span>(pi / <span class="number">6</span>), <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">cos</span>(pi / <span class="number">4</span>),  -<span class="built_in">sin</span>(pi / <span class="number">4</span>),</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sin</span>(pi / <span class="number">4</span>), <span class="built_in">cos</span>(pi / <span class="number">4</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>* B = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * n * n);</span><br><span class="line"><span class="built_in">memset</span>(B, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>) * n * n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">B[j * n + i] = A[i * n + j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; local_n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; local_n; j++)</span><br><span class="line">&#123;</span><br><span class="line">local_A[i * local_n + j] = A[i * n + j];</span><br><span class="line">local_B[i * local_n + j] = B[i * n + j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; dims[<span class="number">0</span>]; row++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; dims[<span class="number">1</span>]; col++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (row == <span class="number">0</span> &amp;&amp; col == <span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//0号进程</span></span><br><span class="line"><span class="comment">//offset是坐标为(row,col)进程对应的A、B子块的第一个元素在A、B矩阵中的下标</span></span><br><span class="line"><span class="type">int</span> offset = row * dims[<span class="number">1</span>] * local_n * local_n + col * local_n;</span><br><span class="line"><span class="type">double</span>* bufferA = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"><span class="type">double</span>* bufferB = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; local_n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; local_n; j++)</span><br><span class="line">&#123;</span><br><span class="line">bufferA[i * local_n + j] = A[offset + i * n + j];</span><br><span class="line">bufferB[i * local_n + j] = B[offset + i * n + j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">coords[<span class="number">0</span>] = row;</span><br><span class="line">coords[<span class="number">1</span>] = col;</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;dstrank);</span><br><span class="line">MPI_Send(bufferA, local_n * local_n, MPI_DOUBLE, dstrank, <span class="number">0</span>, comm_2d);</span><br><span class="line">MPI_Send(bufferB, local_n * local_n, MPI_DOUBLE, dstrank, <span class="number">1</span>, comm_2d);</span><br><span class="line"><span class="built_in">free</span>(bufferA);</span><br><span class="line"><span class="built_in">free</span>(bufferB);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">MPI_Recv(local_A, local_n * local_n, MPI_DOUBLE, <span class="number">0</span>, <span class="number">0</span>, comm_2d, MPI_STATUS_IGNORE);</span><br><span class="line">MPI_Recv(local_B, local_n * local_n, MPI_DOUBLE, <span class="number">0</span>, <span class="number">1</span>, comm_2d, MPI_STATUS_IGNORE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="6、收集结果到0号进程的函数"><a href="#6、收集结果到0号进程的函数" class="headerlink" title="6、收集结果到0号进程的函数"></a>6、收集结果到0号进程的函数</h2><p>所有进程将计算结果（本地$C$子块的数据）放入$bufferC$中发送给0号进程，0号进程收集$bufferC$中的数据放入$C$矩阵的对应位置中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GatherResult</span><span class="params">(MPI_Comm comm_2d, <span class="type">double</span>* local_C)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> otherrank;</span><br><span class="line">MPI_Status status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (coords[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; coords[<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span>* C = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * n * n);</span><br><span class="line"><span class="built_in">memset</span>(C, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>) * n * n);</span><br><span class="line"><span class="type">double</span>* bufferC = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"><span class="built_in">memset</span>(bufferC, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>) * local_n * local_n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; dims[<span class="number">0</span>]; row++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; dims[<span class="number">1</span>]; col++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (row == <span class="number">0</span> &amp;&amp; col == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; local_n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; local_n; j++)</span><br><span class="line">C[i * n + j] = local_C[i * local_n + j];</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">coords[<span class="number">0</span>] = row;</span><br><span class="line">coords[<span class="number">1</span>] = col;</span><br><span class="line">MPI_Cart_rank(comm_2d, coords, &amp;otherrank);</span><br><span class="line">MPI_Recv(bufferC, local_n * local_n, MPI_DOUBLE, otherrank, <span class="number">0</span>, comm_2d, &amp;status);</span><br><span class="line"><span class="type">int</span> offset = row * dims[<span class="number">1</span>] * local_n * local_n + col * local_n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; local_n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; local_n; j++)</span><br><span class="line">C[offset + i * n + j] = bufferC[i * local_n + j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(bufferC);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>, C[i * n + j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">MPI_Send(local_C, local_n * local_n, MPI_DOUBLE, <span class="number">0</span>, <span class="number">0</span>, comm_2d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="四、实现结果"><a href="#四、实现结果" class="headerlink" title="四、实现结果"></a>四、实现结果</h1><p>程序在$VS2019$上运行，可以看到随着进程数量的增加，$0$号进程的运行时间明显减少（显示器上显示的执行时间是$0$号进程的执行时间）。但是当进程增加到原来的$n$倍，$0$号进程的运行时间并不为原来的$\frac{1}{n}$，这一方面是因为$0$号进程需要与更多的进程点对点发送$A$、$B$矩阵的数据，另一个重要原因是我的电脑为$Intel$ $8$核$CPU$，最多只能有$8$个进程同时运行，因此会有$64-8=56$个进程会在等待队列和就绪队列上等待被$CPU$调度，影响总程序运行时间。但是多个进程确实明显加速了矩阵乘法。<br><img data-src="https://img-blog.csdnimg.cn/bf1ed6fdf2b64112bb938e070825e933.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qWa5Zu95Luk5bC5,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">该文章主要介绍并行矩阵乘法的经典算法：Cannon矩阵乘法</summary>
    
    
    
    <category term="并行计算" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="MPI程序设计与并行算法" scheme="http://chudod.github.io/categories/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/MPI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="MPI" scheme="http://chudod.github.io/tags/MPI/"/>
    
    <category term="并行计算" scheme="http://chudod.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="并行算法" scheme="http://chudod.github.io/tags/%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
